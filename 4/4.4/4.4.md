# 4.4. Mapeo entre elementos de Arquitectura

## 00: Decisiones generales

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- { Mapeo entre elementos del frontend, backend y capa de datos para el módulo de Gestión de Usuarios }

**Contexto:**  
{ El módulo de Gestión de Usuarios requiere que las acciones como registro, inicio de sesión y validación de planes se reflejen de forma inmediata y coherente en el sistema. Es necesario definir cómo los componentes del frontend se conectarán con la lógica del backend y cómo esta, a su vez, accederá a la base de datos. }

**Alternativas:**
1. **Mapeo directo entre componentes (controlador → servicio → repositorio)**
     - {Patrón clásico en arquitecturas MVC.}
     - {Comunicación REST entre frontend y backend.}
     - {Servicios centralizan la lógica de negocio.}
     - {Mayor simplicidad y trazabilidad.}

2. **Arquitectura basada en eventos (cola de mensajes)**
     - {Acciones del usuario publican eventos en un bus.}
     - {Servicios escuchan eventos y responden (crear cuenta, validar login, etc).}
     - {Desacople total entre frontend y backend.}
     - {Introduce complejidad operativa.}
     
**Criterios de elección:**
- **Escalabilidad:** { Capacidad de modificar y ampliar el sistema con mas componentes en el tiempo }
- **Mantenibilidad:** { Capacidad de mantener el sistema actualizado en el tiempo. }
- **{Eficiencia de ejecución}:** { Tiempo de respuesta del sistema a las peticiones del usuario. }

**Decisión:**
{ Se elige la Alternativa 1 }

**Sustento:**
{Esta alternativa ofrece una arquitectura clara, sencilla de implementar y suficiente para la complejidad actual del sistema. El uso de colas de mensajes solo aportaría valor en un contexto distribuido o con servicios asincrónicos, lo cual no es una necesidad actual. Además, la trazabilidad y el debugging son más directos bajo este patrón.}


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- { Asignación de responsabilidades entre frontend y backend para el perfil del usuario }

**Contexto:**  
{ El módulo de visualización del perfil involucra varios tipos de información: datos personales, estadísticas y contenidos musicales. Esta información proviene de distintas fuentes y requiere transformación y formato antes de ser presentada. Se debe decidir qué parte del sistema (frontend o backend) será responsable de ensamblar y preparar los datos para su visualización. }

**Alternativas:**
1. **El backend construye el modelo completo del perfil y lo entrega listo al frontend**
     - {El backend consulta, ensambla y transforma todos los datos en una estructura completa.}
     - {El frontend solo se encarga de mostrar la información, sin procesar datos complejos.}
     - {Centraliza la lógica de ensamblado y evita duplicación de reglas en el cliente.}

2. **El backend expone endpoints separados y el frontend ensambla el perfil**
     - {El backend expone distintos endpoints (datos básicos, estadísticas, biblioteca).}
     - {El frontend realiza múltiples peticiones y ensambla la estructura total.}
     - {Aumenta la flexibilidad en la visualización, pero complejiza la lógica en el cliente.}
     
**Criterios de elección:**
- **Modularidad** { Evitar que la lógica de negocio se disperse entre backend y frontend. }
- **Mantenibilidad:** { Facilidad para hacer cambios o extender funcionalidad sin reescribir código en varias partes. }
- **{ Eficiencia de Ejecución }:** { Minimizar la cantidad de llamadas necesarias para cargar el perfil. }

**Decisión:**
{ Se elige la Alternativa 1 }

**Sustento:**
{ Dado que la información del perfil proviene de múltiples módulos (usuarios, estadísticas, biblioteca), centralizar el ensamblado en el backend mejora la mantenibilidad y asegura coherencia en la lógica de negocio. Además, reduce el número de llamadas necesarias para cargar el perfil, mejorando el rendimiento y simplificando el frontend, que solo necesita encargarse de renderizar los datos. }



## 03: Exploración musical

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 04: Gestión de biblioteca

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de recomendaciones

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

