# 4.4. Mapeo entre elementos de Arquitectura

## 00: Decisiones generales

### Decisión 1:
**Título:**
- Mapeo de módulos funcionales a microservicios.

**Contexto:**
Hemos definido varios módulos funcionales en Singletone (Gestión de Usuarios, Visualización de Perfiles, Exploración Musical, Gestión de Biblioteca, Gestión de Recomendaciones, Gestión de Planes). Es necesario definir cómo estos módulos se mapearán a los microservicios que implementarán su funcionalidad.

**Alternativas:**
1. **Mapeo uno a uno: Cada módulo funcional corresponde a un microservicio.**
    - Gestión de Usuarios -> Servicio de Gestión de Usuarios
    - Visualización de Perfiles -> Servicio de Visualización de Perfiles
    - ... y así sucesivamente.
    - Promueve una clara separación de responsabilidades a nivel de servicio.
    - Facilita el despliegue y escalado independiente de cada módulo.
    - Podría resultar en un gran número de microservicios, aumentando la complejidad de la gestión y la comunicación.

2. **Mapeo agrupado: Varios módulos funcionales se agrupan en un solo microservicio.**
    - Por ejemplo, Visualización de Perfiles y Gestión de Biblioteca podrían residir en un mismo microservicio.
    - Reduce el número de microservicios y la complejidad de la comunicación.
    - Podría llevar a un acoplamiento funcional dentro del microservicio, dificultando la escalabilidad y el despliegue independiente de funcionalidades específicas.

3. **Mapeo híbrido: Algunos módulos se mapean uno a uno, mientras que otros se agrupan según su afinidad funcional y requisitos de escalabilidad.**
    - Por ejemplo, Gestión de Usuarios y Gestión de Planes podrían ser microservicios independientes debido a sus distintos requisitos de seguridad y escalabilidad, mientras que Visualización de Perfiles y Gestión de Biblioteca podrían agruparse si comparten muchos datos y patrones de acceso.

**Criterios de elección:**
- **Separación de Responsabilidades:** Mantener los microservicios enfocados en un dominio específico.
- **Escalabilidad:** La capacidad de escalar diferentes partes de la aplicación independientemente.
- **Frecuencia de Despliegue:** La necesidad de desplegar cambios en diferentes módulos de forma independiente.
- **Afinidad Funcional:** La cohesión de las funcionalidades dentro de un microservicio.
- **Tamaño del Equipo:** La organización de los equipos de desarrollo puede influir en el número y tamaño de los microservicios.

**Decisión:**
Mapeo principalmente uno a uno, con una posible agrupación de Visualización de Perfiles y Gestión de Biblioteca en un único microservicio inicial, dado su fuerte acoplamiento en términos de datos y la visualización de la información de la biblioteca en el perfil del usuario. Los demás módulos (Gestión de Usuarios, Exploración Musical, Gestión de Recomendaciones, Gestión de Planes) se implementarán como microservicios independientes.

**Sustento:**
Este enfoque busca un equilibrio entre la separación de responsabilidades y la reducción de la complejidad inicial. La agrupación de Visualización de Perfiles y Gestión de Biblioteca puede simplificar el desarrollo y la gestión de datos relacionados con la información del usuario y su colección musical. Sin embargo, si en el futuro estos módulos presentan diferentes requisitos de escalabilidad o frecuencia de despliegue, podrían separarse en microservicios independientes. Los demás módulos, con funcionalidades más distintas, se benefician de la independencia de sus propios microservicios.


## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 03: Exploración musical

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 04: Gestión de biblioteca

### Decisión 1:
**Título:**
- Mapeo del modelo de datos de la biblioteca a las colecciones de MongoDB.

**Contexto:**
Hemos definido una estructura para el modelo de datos de la biblioteca utilizando colecciones en MongoDB (`user_artists`, `user_albums`, `valoraciones`). Es necesario definir cómo estos elementos del modelo de datos se mapearán a las colecciones físicas en la base de datos MongoDB.

**Alternativas:**
1. **Mapeo directo: Cada entidad principal de la biblioteca corresponde a una colección.**
    - La entidad "relación usuario-artista" se mapea a la colección `user_artists`.
    - La entidad "relación usuario-álbum" se mapea a la colección `user_albums`.
    - La entidad "valoración" se mapea a la colección `valoraciones`.
    - Simple y directo.
    - Refleja claramente el modelo de datos lógico en la estructura física.

2. **Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario:**
    - La información de la biblioteca (artistas y álbumes agregados, con su estado y valoraciones) se incrustaría dentro del documento del usuario en la colección `users`.
    - Reduce el número de colecciones y potencialmente el número de consultas para acceder a la biblioteca de un usuario.
    - Podría llevar a documentos de usuario muy grandes y complejos, dificultando la gestión y las actualizaciones, especialmente para usuarios con grandes bibliotecas.

**Criterios de elección:**
- **Simplicidad:** La facilidad para entender y gestionar el mapeo.
- **Rendimiento de Consulta:** La eficiencia de las consultas para los casos de uso principales (ej. obtener la biblioteca de un usuario, listar valoraciones).
- **Escalabilidad:** El impacto en la escalabilidad de la base de datos.
- **Flexibilidad del Modelo:** La capacidad de adaptar el modelo de datos en el futuro.

**Decisión:**
Mapeo directo: la entidad "relación usuario-artista" se mapea a la colección `user_artists`, la entidad "relación usuario-álbum" a la colección `user_albums`, y la entidad "valoración" a la colección `valoraciones`.

**Sustento:**
Este mapeo directo simplifica la comprensión y la gestión de la estructura de la base de datos. Permite una organización clara de los diferentes tipos de datos relacionados con la biblioteca del usuario. Si bien podría requerir más de una consulta para reconstruir completamente la biblioteca de un usuario, las consultas individuales para listar artistas, álbumes o valoraciones son eficientes. Además, evita los problemas de rendimiento y escalabilidad asociados con documentos de usuario excesivamente grandes.

### Decisión 2:
**Título:**
- Mapeo del concepto de "estado" de artistas y álbumes a campos en la base de datos.

**Contexto:**
El estado de "agregado" o "valorado" para artistas y álbumes en la biblioteca del usuario es un concepto importante en el modelo de datos. Es necesario definir cómo este estado se representará en las colecciones `user_artists` y `user_albums` en MongoDB.

**Alternativas:**
1. **Utilizar un campo de texto (string) para el estado:**
    - Un campo llamado `estado` en las colecciones `user_artists` y `user_albums` que puede contener los valores "agregado" o "valorado".
    - Simple de implementar.
    - Podría ser propenso a errores de escritura y dificultar las consultas basadas en rangos (aunque no es relevante para este caso específico).

2. **Utilizar un campo booleano para indicar si está "valorado":**
    - Un campo llamado `esValorado` (o similar) en las colecciones. La ausencia de este campo o su valor en `false` implicaría "agregado".
    - Más eficiente para consultas booleanas.
    - Podría ser menos explícito sobre los posibles estados en el futuro si se introducen nuevos estados.

3. **Utilizar un campo numérico (entero) para representar el estado mediante un código:**
    - Un campo llamado `codigoEstado` donde 0 podría representar "agregado" y 1 "valorado".
    - Eficiente en términos de almacenamiento.
    - Menos legible directamente en los datos sin una documentación adecuada.

**Criterios de elección:**
- **Claridad:** La facilidad para entender el significado del campo de estado.
- **Eficiencia de Consulta:** El rendimiento de las consultas basadas en el estado.
- **Flexibilidad Futura:** La capacidad de extender el modelo si se necesitan más estados en el futuro.

**Decisión:**
Utilizar un campo de texto (string) llamado `estado` que contenga los valores "agregado" o "valorado" en las colecciones `user_artists` y `user_albums`.

**Sustento:**
Si bien un campo booleano podría ser más eficiente para consultas específicas sobre el estado "valorado", un campo de texto ofrece mayor claridad y flexibilidad para el futuro. Si se llegaran a introducir nuevos estados para los artistas o álbumes en la biblioteca, un campo de texto podría acomodarlos más fácilmente sin necesidad de alterar la estructura del campo. La pequeña sobrecarga de almacenamiento en comparación con un booleano o un entero se considera aceptable en aras de la claridad y la flexibilidad.



## 05: Gestión de recomendaciones

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

