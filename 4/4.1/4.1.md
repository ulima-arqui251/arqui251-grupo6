# 4.1. Asignación de Responsabilidades

## 00: Decisiones generales

### Decisión 1:  
**Título:**
- Elección entre arquitectura monolítica y de microservicios

**Contexto:**  
Singletone es una plataforma musical que requiere manejar múltiples módulos complejos (gestión de usuarios, biblioteca musical, recomendaciones, etc.) con diferentes demandas de escalabilidad y disponibilidad. Con un crecimiento proyectado en usuarios y funcionalidades, es crucial seleccionar una arquitectura que permita escalar componentes individualmente, mantener alta disponibilidad y facilitar el desarrollo continuo sin afectar la experiencia del usuario.

**Alternativas:**
1. **Arquitectura monolítica:**
     - Todos los módulos integrados en una sola aplicación, simplificando el desarrollo inicial y despliegue.
     - Comunicación más sencilla entre componentes al compartir el mismo espacio de memoria.
     - Dificultad para escalar componentes individualmente (ej: módulo de recomendaciones que requiere más recursos).
     - Un fallo en un módulo puede afectar toda la plataforma.
     - Actualizaciones requieren redeploy completo de la aplicación.
     - Limitación a un stack tecnológico único.

2. **Arquitectura de microservicios:**
     - Cada módulo funciona como servicio independiente (ej: servicio de usuarios, servicio de biblioteca, etc.).
     - Escalabilidad granular según demanda de cada módulo.
     - Desarrollo y despliegue independiente por equipos.
     - Tolerancia a fallos aislada (la falla de un módulo no afectará el funcionamiento de Singletone).
     - Mayor complejidad en gestión de infraestructura y comunicación entre servicios.
     - Posibilidad de usar diferentes tecnologías por servicio.
     - Costos operativos más elevados inicialmente.
     
**Criterios de elección:**
- **Escalabilidad:** Capacidad de escalar módulos con alta demanda como recomendaciones y búsqueda musical.
- **Disponibilidad:** Garantizar que fallos en un módulo no afecten toda la plataforma.
- **Velocidad de desarrollo:** Permitir que equipos trabajen en paralelo en diferentes módulos.
- **Flexibilidad tecnológica:** Posibilidad de usar tecnologías específicas por módulo (ej. Python para ML en recomendaciones).
- **Costo/Recursos:** Equipo con capacidad de gestionar arquitectura distribuida.

**Decisión:**
Arquitectura de microservicios.

**Sustento:**
La naturaleza modular de Singletone, con componentes claramente diferenciados (usuarios, biblioteca, recomendaciones) y diferentes necesidades de escalabilidad en base a funcionlidades y políticas, hace ideal el enfoque de microservicios. Esta elección permitirá al equipo:
1. Escalar independientemente el servicio de recomendaciones (que usa ML intensivo) sin afectar otros módulos
2. Aislar fallos (ej. problemas en la compra de suscripciones premium no interrumpiría la valoración o músical o búsqueda de perfiles)
3. Permitir actualizaciones frecuentes del módulo de exploración musical sin requerir deploy completo
4. Usar tecnologías óptimas por módulo (Node.js para API REST, Python para ML)
5. Equipos de desarrollo independientes trabajando en paralelo

Aunque aumenta la complejidad operativa, herramientas como Kubernetes y Docker facilitan la gestión, y los beneficios superan ampliamente los costos para una plataforma en crecimiento como Singletone.

### Decisión 2:  
**Título:**
- Asignación de responsabilidades entre módulos frontend y backend

**Contexto:**  
Singletone es una plataforma web con módulos complejos que requieren alta interactividad (ej: digitación individual para valorar canciones, carruseles dinámicos). Se debe decidir qué lógica reside en el frontend (React) y qué responsabilidades quedan en el backend (Node.js) para optimizar rendimiento y mantenibilidad.

**Alternativas:**
1. **Frontend "grueso":**
     - El frontend maneja lógica de negocio (validaciones, gestión de estado complejo)
     - Backend solo como API REST para persistencia
     - Mayor interactividad pero riesgo de inconsistencia si no se sincroniza con backend
     - Dificulta reutilización para otros clientes (ej: móvil)

2. **Arquitectura de microservicios:**
     - Frontend como capa de presentación (renderizado básico)
     - Backend maneja lógica de negocio y estado
     - Más consistencia pero menor interactividad
     - Mayor carga en el backend

3. **Enfoque híbrido:**
     - Frontend maneja estado de UI y validaciones básicas
     - Backend gestiona estado de negocio y reglas complejas
     - Comunicación via API REST + WebSockets para actualizaciones en tiempo real

**Criterios de elección:**
- **Consistencia:** Garantizar que los datos reflejen siempre el estado correcto.
- **Interactividad:** Tiempo de respuesta para acciones del usuario.
- **Mantenibilidad:** Facilidad para evolucionar componentes.
- **Escalabilidad:** Distribución equilibrada de carga.

**Decisión:**
Enfoque híbrido.
- **Frontend** responsable de:
     - Estado de la UI (ej: canciones siendo valoradas)
     - Validaciones de formato (ej: puntaje entre 1-100)
     - Efectos visuales (carruseles, animaciones)
- **Backend** responsable de:
     - Estado de negocio (ej: valoraciones confirmadas)
     - Reglas complejas (límite semanal de valoraciones)
     - Integración con servicios externos (APIs de metadata musical)

**Sustento:**
El enfoque híbrido entre frontend y backend es el más adecuado para Singletone, ya que permite combinar una experiencia de usuario fluida con una lógica de negocio robusta y mantenible. Al delegar al frontend (React) la gestión del estado de la interfaz, validaciones básicas y efectos visuales, se optimiza la interactividad y la velocidad de respuesta, mientras que el backend (Node.js) asume el control del estado del negocio, reglas complejas y la integración con servicios externos, asegurando consistencia y seguridad en la plataforma. Esta división de responsabilidades no solo facilita la escalabilidad y el trabajo paralelo entre equipos, sino que también prepara la arquitectura para soportar múltiples clientes reutilizando la lógica del backend. Además, la combinación de API REST y WebSockets garantiza una comunicación eficiente y actualizaciones en tiempo real cuando sea necesario.

### Decisión 3:  
**Título:**
- Responsabilidad de la gestión de la identidad y autenticación de usuarios.

**Contexto:**  
La plataforma Singletone requiere un sistema robusto para la gestión de la identidad de los usuarios, incluyendo el registro, inicio de sesión y la gestión de diferentes tipos de cuentas (gratuitas y premium). Es fundamental definir qué componente o servicio será responsable de manejar estas operaciones de manera segura y eficiente.

**Alternativas:**
1. **Integrar la gestión de identidad directamente en el microservicio de Gestión de Usuarios:**
     - El microservicio de Gestión de Usuarios sería responsable de almacenar la información de los usuarios, autenticarlos y verificar el tipo de cuenta.
     - Simplifica la arquitectura inicial al centralizar la lógica de identidad.
     - Podría sobrecargar el microservicio de Gestión de Usuarios a medida que crecen las funcionalidades relacionadas con la identidad (ej. autenticación de dos factores, recuperación de contraseñas).
     - Podría generar dependencias fuertes entre la gestión de usuarios y otras partes del sistema que necesitan verificar la identidad.
2. **Delegar la gestión de identidad a un servicio de identidad dedicado (Identity Provider - IdP):**
     - Se utilizaría un servicio independiente, ya sea desarrollado internamente o una solución de terceros (ej. Keycloak, Auth0), para manejar la autenticación y autorización.
     - Promueve la separación de responsabilidades y mejora la seguridad al centralizar la lógica de autenticación.
     - Permite la adopción de estándares de autenticación (ej. OAuth 2.0, OpenID Connect).
     - Reduce la complejidad del microservicio de Gestión de Usuarios, permitiéndole enfocarse en la gestión de la información del perfil del usuario.
     - Introduce una dependencia adicional en la arquitectura.
     
**Criterios de elección:**
- **Seguridad:** La protección de la información de los usuarios es primordial.
- **Escalabilidad:** La capacidad de manejar un gran número de usuarios y solicitudes de autenticación.
- **Mantenibilidad:** La facilidad para actualizar y mantener el sistema de autenticación.
- **Separación de Responsabilidades:**  Mantener los microservicios enfocados en sus dominios específicos.

**Decisión:**
Delegar la gestión de identidad a un servicio de identidad dedicado (Identity Provider - IdP).

**Sustento:**
Dado el enfoque en la seguridad y la potencial necesidad de integrar diferentes métodos de autenticación en el futuro, un servicio de identidad dedicado ofrece una solución más robusta y escalable. Permite centralizar la lógica de autenticación, aplicar políticas de seguridad consistentes y facilita la integración con otros servicios sin sobrecargar el microservicio de Gestión de Usuarios. Aunque introduce una dependencia adicional, los beneficios en términos de seguridad y mantenibilidad a largo plazo superan este inconveniente.


## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- Separación de responsabilidades de registro, autenticación y gestión de usuarios

**Contexto:**  
El módulo de gestión de usuarios maneja el registro de nuevos usuarios, autenticación de usuarios existentes y determinación del tipo de cuenta. Es importante que se asigne claramente qué componentes del sistema deben hacerse responsables de cada funcionalidad para asegurar claridad, mantenibilidad y escalabilidad.

**Alternativas:**
1. **Separar los controladores en tres componentes específicos:**
     - Controlador: Recibe las solicitudes HTTP, valida lo básico y delega al servicio.
     - Servicio: Contiene la lógica de negocio (registro, login, validaciones).
     - Repositorio (o capa de acceso a datos): Accede a la base de datos, sin lógica de negocio.
     - Facilita la modificación de componentes durante el desarrollo
     - Escalabilidad aumentada
     - Facilita pruebas unitarias al desacoplar responsabilidades.
     - Favorece la mantenibilidad y escalabilidad del sistema.

2. **Controlador único para las tres responsabilidades:**
     - Facil desarrollo durante etapas tempranas.
     - Menor cantidad de archivos o capas.
     - Más rápido de implementar en proyectos simples.
     - Código más acoplado y difícil de testear.
     - Escalabilidad limitada al crecer el proyecto.
     - Menor claridad de responsabilidades.
     
**Criterios de elección:**
- **Escalabilidad:** { Capacidad de modificar y ampliar el sistema con mas componentes en el tiempo }
- **Mantenibilidad:** { Capacidad de mantener el sistema actualizado en el tiempo. }
- **Modularidad:** { Capacidad de desacoplamiento de los componentes del sistema para una baja interdependencia }

**Decisión:**
Separar los controladores en tres componentes específicos.

**Sustento:**
Separar los componentes del módulo nos permite modificar y probar el sistema con mayor facilidad sin afectar otras partes de este. El delegar las responsabilidades entre estos tres componentes permite que el código sea escalable y compatible con futuras integraciones.


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- Separación de responsabilidades entre los componentes de visualización de perfil

**Contexto:**  
El módulo de visualización de perfil debe mostrar información del usuario en diferentes secciones: datos básicos, estadísticas personales, biblioteca musical y opciones premium. Además, debe permitir editar la información del perfil. La correcta distribución de responsabilidades entre los componentes es clave para asegurar mantenibilidad, escalabilidad y claridad en el desarrollo y extensión del sistema.

**Alternativas:**
1. **Separar en componentes independientes por tipo de información (básica, estadísticas, música, premium y edición)**
     - Cada sección del perfil (básica, estadísticas, música, premium, edición) se implementa como un componente o servicio separado.
     - Se puede reutilizar y mantener cada parte de forma aislada.
     - Permite ocultar o mostrar secciones según tipo de usuario (premium o gratuito).
     - Facilita pruebas unitarias y el debugging por componente.

2. **Un único componente que renderiza todas las secciones del perfil juntas**
     - Toda la lógica y visualización del perfil se gestiona desde un único archivo o componente.
     - Menos archivos, menos configuración inicial.
     - Cambio en cualquier parte del perfil afecta al componente entero.
     - Difícil escalar o agregar nuevas secciones premium.
     
**Criterios de elección:**
- **Escalabilidad:** Facilidad para extender el sistema (agregar nuevas secciones o funciones).
- **Mantenibilidad:** Capacidad de modificar el código fácilmente ante cambios o mejoras sin afectar otras partes del sistema.
- **Reusabilidad:** Posibilidad de utilizar partes del código (como estadísticas o carruseles) en otras vistas o módulos.

**Decisión:**
Separar en componentes independientes por tipo de información (básica, estadísticas, música, premium y edición)

**Sustento:**
Dividir el perfil en componentes según el tipo de información permite escalar el sistema en el futuro (por ejemplo, si se agregan nuevas estadísticas o nuevas listas premium). Además, facilita mantener la lógica de negocio separada de la interfaz visual, lo que contribuye a un código más limpio, reutilizable y fácil de probar. Dado que hay múltiples historias de usuario que afectan diferentes partes del perfil, esta separación modular es la más adecuada.



## 03: Exploración musical

### Decisión 1:  
**Título:**
- Responsabilidad exclusiva de música y visualización de resultados musicales y de usuarios

**Contexto:**  
El módulo 03 de Singletone permite a los usuarios buscar álbumes, artistas y otros usuarios dentro de la plataforma. Esta funcionalidad es clave para la experiencia del usuario, ya que es el primer paso para descubrir nueva música o conectar con otros. Al encontrar resultados relevantes, los usuarios pueden agregar álbumes y artistas a su biblioteca personal directamente desde este módulo. Esto implica que el módulo no solo muestra resultados, sino que también debe enviar eventos o peticiones al módulo de biblioteca para gestionar estas acciones. Es importante definir hasta dónde llega esta responsabilidad para evitar que el módulo gestione el almacenamiento o estados internos de la biblioteca, que es competencia del módulo 04.

**Alternativas:**
1. **Módulo de Búsqueda Pasiva:**
     - Limitar el módulo solo a mostrar resultados de búsqueda, sin permitir interacciones como agregar elementos a la biblioteca.

2. **Módulo de Búsqueda con Acción Delegada:**
     - Ampliar la responsabilidad para que el módulo permita buscar, mostrar resultados e iniciar el proceso de agregar elementos a la biblioteca, dejando la gestión interna al módulo correspondiente.
     
**Criterios de elección:**
- **Experiencia de Usuario:** Facilitar que el usuario pueda agregar elementos desde la misma vista mejora la usabilidad.
- **Mantenibilidad:** Al dejar la gestión de datos y reglas de negocio en el módulo especializado, se reduce la necesidad de modificar el módulo de exploración ante cambios en las reglas de biblioteca.
- **Separación de Responsabilidades:** Aunque permite iniciar el agregado, no gestiona directamente el almacenamiento ni los estados de la biblioteca.
- **Escalabilidad:** Mantener la lógica de almacenamiento en otro módulo permite que ambos evolucionen de forma independiente.

**Decisión:**
Módulo de Búsqueda con Acción Delegada.

**Sustento:**
Esta decisión permite que la experiencia del usuario sea más fluida, ya que puede agregar elementos directamente desde la exploración. Sin embargo, solamente se tendrá la opción de agregar elementos a la biblioteca, debido a que si se abarca más allá de esa funcionalidad, se estaría abarcando territorio del módulo 04 (Gestión de biblioteca), como por ejemplo, si se añadiera la opción de eliminar. Incorporar dicha funcionalidad no sería adecuado, ya que interrumpe el flujo lógico de la arquitectura, donde el módulo 04 es el único responsable de administrar, modificar y mantener la biblioteca del usuario, además, existiría una duplicidad de lógica y aumentaría la complejidad del mantenimiento, vulnerando el principio de responsabilidad única. De esta forma también se evitarían acoplamientos innecesarios y se estaría contribuyendo a una escalabilidad simple.

## 04: Gestión de biblioteca

### Decisión 1:  
**Título:**
- Estrategia para el almacenamiento del estado de "agregado" y "valorado" de artistas y álbumes.

**Contexto:**  
El módulo de gestión de biblioteca necesita mantener el estado de los artistas y álbumes agregados por cada usuario. Un artista puede estar en estado "agregado" si no todos sus álbumes han sido valorados, y "valorado" si todos sus álbumes agregados han sido valorados. De manera similar, un álbum puede estar "agregado" si no todas sus canciones han sido valoradas, y "valorado" si todas lo han sido. Esta información es crucial para la visualización del perfil y la navegación en la biblioteca.

**Alternativas:**
1. **Almacenar el estado directamente en las entidades de Artista y Álbum del usuario:**
     - Se añadirían campos booleanos (o un enum) a las entidades de Artista y Álbum dentro del modelo de datos del usuario para indicar su estado.
     - Simple de implementar inicialmente.
     - Las consultas para obtener el estado son directas.
     - Puede generar inconsistencias si la lógica de valoración no actualiza correctamente estos estados en todos los casos.
     - Podría complicar las consultas si se necesitan filtrar usuarios por el estado de sus artistas/álbumes.

2. **Calcular el estado dinámicamente en base a las valoraciones del usuario:**
     - El estado de un artista o álbum se determinaría consultando las valoraciones del usuario para todos los álbumes del artista o todas las canciones del álbum.
     - Asegura la consistencia de los datos, ya que el estado siempre se basa en la información de valoración actual.
     - Puede generar consultas más complejas y potencialmente más lentas, especialmente para usuarios con grandes bibliotecas.
     - Requiere lógica adicional en la capa de servicio para determinar el estado.
     
3. **Utilizar una tabla de "relación" explícita con un campo de estado:**
     - Se crearía una tabla intermedia que relacione usuarios con artistas y álbumes, incluyendo un campo para el estado ("agregado", "valorado").
     - Permite una gestión más clara del estado y facilita las consultas basadas en el estado.
     - Introduce una complejidad adicional en el modelo de datos y las operaciones de lectura/escritura.
     - Facilita la extensión futura con más metadatos sobre la relación usuario-artista/álbum.

**Criterios de elección:**
- **Consistencia de Datos:** Asegurar que el estado refleje con precisión las valoraciones del usuario.
- **Rendimiento de Lectura:** La velocidad con la que se puede obtener el estado para la visualización del perfil y la navegación.
- **Complejidad de Implementación:** El esfuerzo necesario para implementar y mantener la solución.
- **Escalabilidad:** Cómo la solución afectará el rendimiento a medida que la biblioteca del usuario crezca.

**Decisión:**
Utilizar una tabla de "relación" explícita con un campo de estado.

**Sustento:**
Si bien la opción de calcular el estado dinámicamente garantiza la consistencia, podría impactar el rendimiento de las lecturas en perfiles con grandes bibliotecas. Al utilizar una tabla de relación explícita (UserArtistAlbum) con un campo de estado, se logra un equilibrio entre la consistencia (al actualizar el estado cada vez que se valora una canción o álbum) y el rendimiento de lectura (al poder consultar directamente el estado). Esta opción también ofrece mayor flexibilidad para futuras extensiones, como almacenar la fecha en que se agregó un artista o álbum a la biblioteca. La complejidad adicional en la implementación se justifica por la mejora en la mantenibilidad y escalabilidad a largo plazo.

### Decisión 2:  
**Título:**
- Responsabilidad de la actualización del estado "agregado" y "valorado" de artistas y álbumes.

**Contexto:**  
Es crucial mantener actualizado el estado de "agregado" y "valorado" de los artistas y álbumes de cada usuario. Es necesario definir qué componente del sistema será responsable de realizar estas actualizaciones en respuesta a las acciones del usuario (agregar álbumes, valorar canciones).

**Alternativas:**
1. **El microservicio de Gestión de Biblioteca maneja directamente las actualizaciones de estado:**
     - Cuando un usuario agrega un álbum o valora una canción, el microservicio de Gestión de Biblioteca sería responsable de actualizar el estado correspondiente en la base de datos.
     - Mantiene la lógica de gestión de la biblioteca centralizada.
     - Podría volverse complejo si la lógica de actualización del estado se vuelve muy elaborada.

2. **El microservicio de Valoración Musical emite eventos que son consumidos por el microservicio de Gestión de Biblioteca para actualizar el estado:**
     - Cuando el microservicio de Valoración Musical registra una valoración (o la eliminación de una valoración), emitiría un evento (ej. "CanciónValorada", "ValoracionEliminada").
     - El microservicio de Gestión de Biblioteca escucharía estos eventos y actualizaría el estado de los artistas y álbumes correspondientes.
     - Promueve el desacoplamiento entre los microservicios.
     - Facilita la auditoría y el seguimiento de los cambios de estado.
     - Introduce la necesidad de una infraestructura de mensajería (ej. RabbitMQ, Kafka).
     
**Criterios de elección:**
- **Consistencia de Datos:** Asegurar que el estado se actualice de manera confiable.
- **Desacoplamiento:** Minimizar las dependencias directas entre microservicios.
- **Escalabilidad:** La capacidad de manejar un gran volumen de valoraciones y actualizaciones de estado.
- **Mantenibilidad:** La facilidad para entender y modificar la lógica de actualización del estado.

**Decisión:**
El microservicio de Valoración Musical emite eventos que son consumidos por el microservicio de Gestión de Biblioteca para actualizar el estado.

**Sustento:**
Este enfoque promueve un mejor desacoplamiento entre los microservicios de Valoración Musical y Gestión de Biblioteca. El microservicio de Valoración Musical se enfoca en registrar las valoraciones, y el microservicio de Gestión de Biblioteca se encarga de mantener la integridad de la biblioteca del usuario basándose en estos eventos. Esto facilita la escalabilidad y la mantenibilidad, ya que los cambios en la lógica de valoración no impactan directamente la gestión de la biblioteca, y viceversa. La introducción de una infraestructura de mensajería se justifica por los beneficios en términos de desacoplamiento y la posibilidad de extender el sistema con otros consumidores de estos eventos en el futuro.

### Decisión 3:  
**Título:**
- Responsabilidad de la notificación de límites de valoración para usuarios gratuitos.

**Contexto:**  
Los usuarios con plan gratuito tienen un límite de 50 valoraciones semanales. El sistema debe notificarles cuando se acerquen a este límite (40, 30, 20, 10 y 0 valoraciones restantes) a través de un snack bar. Es necesario definir qué componente del sistema será responsable de rastrear el número de valoraciones realizadas por usuarios gratuitos y de activar estas notificaciones.

**Alternativas:**
1. **El microservicio de Valoración Musical rastrea y notifica los límites:**
     - El microservicio de Valoración Musical mantendría un registro del número de valoraciones realizadas por cada usuario gratuito en la semana actual.
     - Sería responsable de determinar cuándo se alcanzan los umbrales de notificación y de enviar la información al frontend para mostrar el snack bar.
     - Centraliza la lógica relacionada con las valoraciones y sus límites.
     - Introduce la necesidad de que el microservicio de backend tenga conocimiento de la capa de presentación (snack bar), lo cual no es ideal para la separación de capas.

2. **El microservicio de Gestión de Biblioteca rastrea los límites y coordina las notificaciones::**
     - El microservicio de Gestión de Biblioteca podría mantener un contador de las valoraciones semanales por usuario gratuito.
     - Recibiría eventos del microservicio de Valoración Musical cada vez que se realiza una valoración.
     - Sería responsable de determinar cuándo se alcanzan los umbrales y comunicarse con un servicio de notificaciones (o directamente con el frontend a través de un canal en tiempo real) para mostrar el snack bar.
     - Mantiene la lógica de la biblioteca y sus reglas (como los límites de valoración) juntas.
     - Requiere una forma de comunicar las notificaciones al usuario en el frontend.
     
3. **Un servicio de "Límites y Políticas" dedicado rastrea y notifica:**
     - Se crearía un microservicio específico responsable de rastrear y aplicar todas las políticas relacionadas con los planes de usuario, incluyendo los límites de valoración.
     - El microservicio de Valoración Musical notificaría a este servicio cada nueva valoración.
     - El servicio de "Límites y Políticas" determinaría cuándo notificar al usuario y se comunicaría con un servicio de notificaciones o directamente con el frontend.
     - Promueve una clara separación de responsabilidades para la lógica de políticas.
     - Introduce un microservicio adicional.

**Criterios de elección:**
- **Separación de Responsabilidades:** Mantener los microservicios enfocados en sus dominios.
- **Cohesión:** Agrupar la lógica relacionada con una funcionalidad específica.
- **Escalabilidad:** La capacidad de manejar un gran número de usuarios y valoraciones.
- **Complejidad:** El número de componentes y la complejidad de la comunicación entre ellos.

**Decisión:**
El microservicio de Valoración Musical rastrea y notifica los límites.

**Sustento:**
Si bien la separación de responsabilidades es importante, en este caso, la lógica del límite de valoraciones está intrínsecamente ligada a la acción de valorar. Mantener esta lógica dentro del microservicio de Valoración Musical simplifica el flujo y reduce la necesidad de comunicación adicional entre microservicios para esta funcionalidad específica. Para evitar el acoplamiento con la presentación, el microservicio de Valoración Musical podría emitir un evento de "LímiteAlcanzado" que el frontend (u otro servicio responsable de la interfaz de usuario) consumiría para mostrar el snack bar. Esto mantiene al backend enfocado en la lógica de negocio sin depender directamente de los detalles de la interfaz de usuario.


## 05: Gestión de recomendaciones

## Decisión 1:
**Título:**
- Estrategia para el almacenamiento y cálculo de recomendaciones de artistas y álbumes.

**Contexto:**  
El módulo de Gestión de Recomendaciones debe proporcionar recomendaciones personalizadas de artistas y álbumes basados en el comportamiento y las valoraciones previas de los usuarios. Estas recomendaciones deben ser dinámicas y actualizadas en tiempo real a medida que el usuario interactúa con la plataforma. Es necesario determinar cómo almacenar y calcular estas recomendaciones de manera eficiente.

**Alternativas:**
1. **Almacenar recomendaciones precalculadas:**
   - Las recomendaciones para cada usuario se generan y almacenan en la base de datos cuando se realiza una acción significativa (ej. nueva valoración, nueva interacción con la biblioteca).
   - Las recomendaciones se almacenan en una colección como `user_recommendations` con campos para los artistas y álbumes recomendados.
   - Consultas rápidas para obtener recomendaciones ya precalculadas.
   - Puede volverse costoso en términos de almacenamiento y actualización frecuente de las recomendaciones.
   - No refleja de manera precisa las interacciones más recientes del usuario, ya que las recomendaciones podrían no estar siempre actualizadas.

2. **Calcular recomendaciones dinámicamente en tiempo real:**
   - Cada vez que el usuario accede a las recomendaciones, se calculan dinámicamente utilizando el historial de interacciones y valoraciones del usuario, posiblemente usando un modelo de machine learning.
   - Permite que las recomendaciones sean más precisas y estén siempre actualizadas.
   - Requiere un mayor poder de cómputo y podría afectar el rendimiento si el cálculo es complejo.
   - Ofrece flexibilidad para mejorar y ajustar los algoritmos de recomendación a medida que se obtiene más información.

3. **Mezcla de precálculo y cálculo en tiempo real:**
   - Se almacenan algunas recomendaciones precalculadas para usuarios con patrones de interacción estables, y otras recomendaciones se calculan dinámicamente para usuarios con comportamientos más variables.
   - Se pueden realizar precálculos para las recomendaciones más comunes y calcular en tiempo real las recomendaciones más específicas o personalizadas.
   - Permite equilibrar la carga de trabajo y mantener un rendimiento adecuado mientras se ofrece personalización.

**Criterios de elección:**
- **Precisión de las recomendaciones:** Cuánto reflejan las recomendaciones el comportamiento y las preferencias actuales del usuario.
- **Rendimiento:** La rapidez con la que las recomendaciones se pueden proporcionar al usuario.
- **Escalabilidad:** Cómo afectará el volumen de usuarios y sus interacciones en el rendimiento del sistema.
- **Costo de mantenimiento:** La facilidad de mantener el sistema actualizado sin sobrecargar la infraestructura.

**Decisión:**
Mezcla de precálculo y cálculo en tiempo real.

**Sustento:**
El enfoque mixto permite aprovechar la eficiencia del almacenamiento de recomendaciones precalculadas para usuarios con patrones más estables, mientras que las recomendaciones dinámicas pueden ser generadas para usuarios con preferencias más cambiantes. Esto ofrece un balance adecuado entre precisión y rendimiento, asegurando que las recomendaciones sean relevantes y actualizadas sin comprometer la capacidad de respuesta del sistema.

---

## Decisión 2:
**Título:**
- Responsabilidad del cálculo de recomendaciones de artistas y álbumes.

**Contexto:**  
El sistema de recomendaciones debe ser responsable de calcular qué artistas y álbumes se deben sugerir a un usuario basado en su historial de interacciones y valoraciones. Es necesario definir qué componente del sistema será responsable de este cálculo y cómo se gestionará este proceso de manera eficiente.

**Alternativas:**
1. **El microservicio de Gestión de Recomendaciones maneja directamente el cálculo:**
   - El microservicio de Gestión de Recomendaciones se encargaría de procesar el historial del usuario, analizar sus interacciones y valoraciones, y generar las recomendaciones.
   - Centraliza la lógica de cálculo de recomendaciones.
   - Puede resultar en una lógica compleja dentro del microservicio, afectando la escalabilidad a medida que el número de usuarios crece.

2. **Un servicio de Machine Learning especializado calcula las recomendaciones:**
   - Se utilizaría un modelo de machine learning para calcular las recomendaciones basadas en el comportamiento histórico del usuario.
   - El microservicio de Gestión de Recomendaciones solo se encargaría de gestionar las recomendaciones y almacenarlas.
   - Promueve la especialización y el desacoplamiento, permitiendo mejoras futuras en el modelo de recomendación.
   - Requiere integrar un modelo de machine learning y gestionar su entrenamiento y actualización periódica.

3. **Uso de un servicio de recomendaciones externo (API de terceros):**
   - Se utilizaría un servicio externo (por ejemplo, una API de recomendaciones) para calcular las recomendaciones y se integrarían en la plataforma.
   - Permite delegar la complejidad del cálculo de recomendaciones a un servicio especializado.
   - Puede ser más económico en términos de desarrollo y mantenimiento, pero puede implicar dependencia de un tercero y limitaciones de personalización.

**Criterios de elección:**
- **Eficiencia:** La capacidad de generar recomendaciones de manera rápida y precisa.
- **Desacoplamiento:** Cuánto se puede separar la lógica de recomendaciones del resto del sistema.
- **Escalabilidad:** Cómo el sistema puede manejar un gran número de usuarios y cálculos de recomendaciones sin afectar el rendimiento.
- **Flexibilidad:** La capacidad de adaptar el sistema para mejorar la precisión de las recomendaciones con el tiempo.

**Decisión:**
El microservicio de Gestión de Recomendaciones maneja directamente el cálculo.

**Sustento:**
El microservicio de Gestión de Recomendaciones es el componente más adecuado para manejar la lógica de recomendación en función del historial y las interacciones del usuario. Esto permite una integración más fluida con el resto del sistema y simplifica el proceso de personalización de las recomendaciones. Aunque el cálculo puede volverse más complejo con el tiempo, el uso de un servicio de machine learning especializado podría implementarse más adelante si se requiere mayor precisión.

---

## Decisión 3:
**Título:**
- Responsabilidad del botón "Volver a recomendar" para recalcular recomendaciones.

**Contexto:**  
El módulo de Gestión de Recomendaciones debe ofrecer a los usuarios la posibilidad de recalcular las recomendaciones si no están conformes con las sugerencias proporcionadas. Es necesario definir quién se encargará de gestionar esta acción y cómo se actualizarán las recomendaciones.

**Alternativas:**
1. **El microservicio de Gestión de Recomendaciones maneja el botón:**
   - El microservicio de Gestión de Recomendaciones se encargaría de recibir la solicitud de "volver a recomendar", procesar las nuevas recomendaciones, y actualizar la interfaz de usuario.
   - Esto permite que el microservicio centralice el control de las recomendaciones.
   - Podría generar una carga adicional en el microservicio cuando muchos usuarios interactúan con la funcionalidad.

2. **El frontend maneja la solicitud y emite un evento al backend:**
   - El frontend gestionaría la solicitud de "volver a recomendar" y emitiría un evento (por ejemplo, "RecomendacionesRecalcular") al microservicio correspondiente.
   - Esto permite que el frontend controle la experiencia del usuario, mientras que el backend solo procesa las recomendaciones.
   - Introduce una mayor complejidad en la arquitectura al incluir más eventos entre frontend y backend.

**Criterios de elección:**
- **Experiencia del Usuario:** La rapidez y fluidez con la que los usuarios puedan recalcular sus recomendaciones.
- **Desacoplamiento:** La separación entre las responsabilidades del frontend y el backend.
- **Rendimiento:** Cómo la acción de recalcular las recomendaciones afectará al rendimiento del sistema.

**Decisión:**
El microservicio de Gestión de Recomendaciones maneja el botón.

**Sustento:**
Dado que la recalificación de las recomendaciones es un proceso que implica el análisis de datos históricos y comportamentales, es más eficiente que el microservicio de Gestión de Recomendaciones se encargue de esta acción. De este modo, se centraliza la lógica y el proceso, mejorando el rendimiento y manteniendo la experiencia del usuario consistente.

## 06: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **{ otro criterio }:** { escribir }
- **{ otro criterio }:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

