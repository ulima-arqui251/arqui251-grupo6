# 4. Decisiones Iniciales de Arquitectura

En esta página se resumen las decisiones tomadas para la arquitectura del aplicativo "Singletone".

## Generalidades
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Elección entre arquitectura monolítica y de microservicios | 1. Arquitectura monolítica, 2. Arquitectura de microservicios | 2. Arquitectura de microservicios |
| Asignación de responsabilidades | Asignación de responsabilidades entre módulos frontend y backend | 1. Frontend "grueso", 2. Backend "grueso", 3. Enfoque híbrido | 3. Enfoque híbrido                   |
| Asignación de responsabilidades | Responsabilidad de la gestión de la identidad y autenticación de usuarios | 1. Integrar en Gestión de Usuarios, 2. Delegar a IdP | 2. Delegar a IdP                     |
| Modelo de Coordinación | Mecanismo de comunicación entre microservicios | 1. Comunicación síncrona(RESTful API), 2. Comunicación asíncrona basada en eventos (Message Broker) | 1. Comunicación síncrona (RESTful API) |
| Modelo de Datos | Estrategia general de persistencia de datos | 1. Utilizar una única base de datos relacional (SQL), 2. Utilizar múltiples bases de datos relacionales (SQL) segregadas por microservicio, 3.Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orientada a documentos y clave-valor | 3. Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orienda a documentos y clave-valor |
| Mapeo entre elementos de Arquitectura | Mapeo de módulos funcionales a microservicios | 1. Mapeo uno a uno, 2. Mapeo agrupado, 3. Mapeo híbrido | 3. Mapeo Híbrido |
| Elección de Tecnología | Tecnología para el desarrollo del Frontend | 1. React, 2. Angular, 3. Vue.js | 1. React |
| Elección de Tecnología | Tecnología para el desarrollo del Backend | 1. Node.js con Express.js, 2. Python con Django o Flask, 3. Java con Spring Boot | 1. Node.js con Express.js |
| Elección de Tecnología | Tecnología para la base de datos relacional | 1. PostgreSQL, 2. MySQL, 3. MariaDB | 1. PostgreSQL |
| Elección de Tecnología | Tecnología para la base de datos NoSQL documental | 1. MongoDB, 2. CouchDB, 3. Amazon DocumentDB | 1. MongoDB |
| Elección de Tecnología | Tecnología para la base de datos NoSQL clave-valor | 1. Redis, 2. Amazon DynamoDB (modo clave-valor), 3. Etcd | 1. Redis |
| Elección de Tecnología | Tecnología para la orquestación de contenedores | 1. Kubernetes, 2. Docker Swarm, 3. Amazon ECS | 1. Kubernetes |

## Módulo 01:
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Separación de responsabilidades de registro, autenticación y gestión de usuarios | 1. Separar los controladores en tres componentes específicos, 2. Controlador único para las tres responsabilidades | 1. Separar los controladores en tres componentes específicos | 
| Modelo de Cordinación | Estrategia de coordinación entre servicios para el flujo de registro de usuarios | 1. Coordinación basada en orquestación mediante un servicio centralizado (UserService), 2. Coordinación distribuida, con múltiples servicios colaborando entre sí | 1. Coordinación basada en orquestación mediante un servicio centralizado (UserService) |
| Modelo de Datos | Modelo de Datos para Entidad Usuario y Estructura de Plan de Suscripción | 1. Modelo relacional normalizado (SQL - PostgresSQL), 2. Modelo documental (NoSQL – MongoDB) | 1. Modelo relacional normalizado (SQL - PostgresSQL) |
| Mapeo entre elementos de arquitectura | Mapeo entre elementos del frontend, backend y capa de datos para el módulo de Gestión de Usuarios | 1. Mapeo directo entre componentes (controlador → servicio → repositorio), 2. Arquitectura basada en eventos (cola de mensajes) | 1. Mapeo directo entre componentes (controlador → servicio → repositorio) |
| Elección de Tecnología | Elección del sistema de autenticación y gestión de usuarios | 1. Firebase Authentication + Firestore, 2. Backend personalizado (Node.js + Express + JWT + PostgreSQL) | 1. Firebase Authentication + Firestore |

## Módulo 02:
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Separación de responsabilidades entre los componentes de visualización de perfil | 1. Separar en componentes independientes por tipo de información (básica, estadísticas, música, premium y edición), 2. Un único componente que renderiza todas las secciones del perfil juntas | 1. Separar en componentes independientes por tipo de información (básica, estadísticas, música, premium y edición) |
| Modelo de Coordinación | Coordinación entre secciones del perfil y otros módulos (usuarios, monetización y biblioteca) | 1. Modelo basado en servicios coordinados mediante un controlador central de perfil, 2. Modelo distribuido en el que cada componente hace sus propias llamadas a servicios externos | 1. Modelo basado en servicios coordinados mediante un controlador central de perfil |
| Modelo de Datos | Estructura de datos para representar la información del perfil del usuario | 1. Modelo separado por dominios (composición de modelos especializados), 2. Modelo monolítico de perfil unificado |  1. Modelo separado por dominios (composición de modelos especializados) |
| Mapeo entre elementos de Arquitectura | Asignación de responsabilidades entre frontend y backend para el perfil del usuario | 1. El backend construye el modelo completo del perfil y lo entrega listo al frontend, 2. El backend expone endpoints separados y el frontend ensambla el perfil | 1. El backend construye el modelo completo del perfil y lo entrega listo al frontend |
| Elección de Tecnología | Elección de la librería de visualización para los carruseles y gráficos en el perfil del usuario | 1. Uso de Swiper.js para carruseles + Recharts para estadísticas, 2. Uso de Slick Carousel + Chart.js | 1. Uso de Swiper.js para carruseles + Recharts para estadísticas |

## Módulo 03:
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Responsabilidad exclusiva de música y visualización de resultados musicales y de usuarios | 1. Módulo de Búsqueda Pasiva, 2. Módulo de Búsqueda con Acción Delegada | 2. Módulo de Búsqueda con Acción Delegada |
| Modelo de Coordinación | Coordinación síncrona para interacción en tiempo real con módulos de Biblioteca y Perfiles | 1. Comunicación vía REST API, 2. Comunicación asíncrona vía eventos o colas de mensajes, 3. Enfoque híbrido (REST para acciones críticas y eventos para procesos secundarios) | 1. Comunicación vía REST API |
| Modelo de Datos | Estructura óptima de los documentos musicales en MongoDB para búsquedas flexibles y rendimiento en exploración | 1. Documentos planos e independientes por entidad, 2. Documentos embebidos por jerarquía de uso, 3. Modelo mixto con desnormalización parcial | 3. Modelo mixto con desnormalización parcial |
| Mapeo entre elementos de Arquitectura | Tipo de comunicación entre el microservicio de exploración y otros módulos de la plataforma | 1. Comunicación síncrona vía HTTP (REST), 2. Comunicación asíncrona vía eventos (mensajería) | 1. Comunicación asíncrona vía eventos (mensajería) |
| Elección de Tecnología | Mecanismo de paginación y autocompletado para búsquedas en el módulo de exploración | 1. Paginación clásica con MongoDB (`skip/limit`) y búsqueda por prefijo, 2. Motor de búsqueda ElasticSearch con scroll infinito y `completion suggester`, 3. Cursor-based pagination con Redis para caché de autocompletado | 2. Motor de búsqueda ElasticSearch con scroll infinito y `completion suggester` |

## Módulo 04:
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Estrategia para el almacenamiento del estado de "agregado" y "valorado" de artistas y álbumes | 1. Almacenar el estado directamente en las entidades de Artista y Álbum del usuario, 2. Calcular el estado dinámicamente en base a las valoraciones del usuario, 3. Utilizar una tabla de "relación" explícita con un campo de estado | 3. Utilizar una tabla de "relación" explícita con un campo de estado |
| Asignación de Responsabilidades | Responsabilidad de la actualización del estado "agregado" y "valorado" de artistas y álbumes | 1. El microservicio de Gestión de Biblioteca maneja directamente las actualizaciones de estado, 2. El microservicio de Valoración Musical emite eventos que son consumidos por el microservicio de Gestión de Biblioteca para actualizar el estado | 2. El microservicio de Valoración Musical emite eventos que son consumidos por el microservicio de Gestión de Biblioteca para actualizar el estado |
| Asignación de Responsabilidades | Responsabilidad de la notificación de límites de valoración para usuarios gratuitos | 1. El microservicio de Valoración Musical rastrea y notifica los límites, 2. El microservicio de Gestión de Biblioteca rastrea los límites y coordina las notificaciones, 3. Un servicio de "Límites y Políticas" dedicado rastrea y notifica | 1. El microservicio de Valoración Musical rastrea y notifica los límites |
| Modelo de Coordinación | Coordinación para la eliminación de artistas y sus álbumes asociados | 1. El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente, 2. El microservicio de Gestión de Biblioteca emite un evento de "ArtistaEliminado" que es consumido por otros componentes para eliminar los álbumes asociados | 1. El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente |
| Modelo de Coordinación | Coordinación del proceso de valoración de álbumes y la activación de la opción "guardar" | 1. El frontend consulta al backend (microservicio de Valoración Musical) para verificar si todas las canciones han sido valoradas antes de habilitar el botón "guardar", 2. El backend (microservicio de Valoración Musical) notifica al frontend (a través de un canal en tiempo real) cuando todas las canciones de un álbum han sido valoradas para que el frontend habilite el botón "guardar", 3. El frontend mantiene el estado de las valoraciones y habilita el botón "guardar" localmente, y luego envía todas las valoraciones al backend al guardar | 2. El backend (microservicio de Valoración Musical) notifica al frontend (a través de un canal en tiempo real) cuando todas las canciones de un álbum han sido valoradas para que el frontend habilite el botón "guardar" |
| Modelo de Datos | Estructura de datos para la biblioteca del usuario | 1. Almacenar la biblioteca como una lista de referencias en el documento del usuario (en MongoDB), 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado, 3. Utilizar tablas relacionales (en PostgreSQL) para las relaciones usuario-artista y usuario-álbum con información de estado | 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado |
| Modelo de Datos | Estructura de datos para la biblioteca del usuario | 1. Almacenar la biblioteca como una lista de referencias en el documento del usuario (en MongoDB), 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado, 3. Utilizar tablas relacionales (en PostgreSQL) para las relaciones usuario-artista y usuario-álbum con información de estado | 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado |
| Modelo de Datos | Estructura de datos para las valoraciones de álbumes y canciones | 1. Incorporar las valoraciones como un subdocumento dentro del documento del álbum en la biblioteca del usuario (en MongoDB), 2. Crear una colección separada de "Valoraciones" en MongoDB, 3. Utilizar tablas relacionales (en PostgreSQL) para almacenar las valoraciones | 2. Crear una colección separada de "Valoraciones" en MongoDB |
| Modelo de Datos | Metadatos para artistas, álbumes y canciones | 1. Almacenar todos los metadatos en una única colección "Música" en MongoDB, 2. Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones, 3. Utilizar tablas relacionales (en PostgreSQL) para almacenar los metadatos | 3. Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones" |
| Mapeo entre elementos de Arquitectura | Mapeo del modelo de datos de la biblioteca a las colecciones de MongoDB | 1. Mapeo directo: Cada entidad principal de la biblioteca corresponde a una colección, 2. Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario | 1. Mapeo directo: Cada entidad Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario |
| Mapeo entre elementos de Arquitectura | Mapeo del concepto de "estado" de artistas y álbumes a campos en la base de datos | 1. Utilizar un campo de texto (string) para el estado, 2. Utilizar un campo booleano para indicar si está "valorado", 3. Utilizar un campo numérico (entero) para representar el estado mediante un código | Utilizar un campo de texto (string) llamado `estado` |
| Eleción de Tecnología | Tecnología para la manipulación de datos en el microservicio de Gestión de Biblioteca | 1. PostgreSQL (pg | sequelize | typeorm), 2. MongoDB (mongodb | mongoose | mongoskin) | 1. PostgreSQL (sequelize), 2. MongoDB (mongoose) |
| Elección de Tecnología | Tecnología para la comunicación en tiempo real (notificaciones de límite de valoraciones) | 1. WebSockets, 2. Server-Sent Events (SSE), 3. Polling o Long Polling | 1. WebSockets |

## Módulo 05:
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Estrategia para el almacenamiento y cálculo de recomendaciones de artistas y álbumes | 1. Almacenar recomendaciones precalculadas, 2. Calcular recomendaciones dinámicamente en tiempo real, 3. Mezcla de precálculo y cálculo en tiempo real | 3. Mezcla de precálculo y cálculo en tiempo real |
| Asignación de Responsabilidades | Responsabilidad del cálculo de recomendaciones de artistas y álbumes | 1. El microservicio de Gestión de Recomendaciones maneja directamente el cálculo, 2. Un servicio de Machine Learning especializado calcula las recomendaciones, 3. Uso de un servicio de recomendaciones externo (API de terceros) | 1. El microservicio de Gestión de Recomendaciones maneja directamente el cálculo |
| Asignación de Responsabilidades | Responsabilidad del botón "Volver a recomendar" para recalcular recomendaciones | 1. El microservicio de Gestión de Recomendaciones maneja el botón, 2. El frontend maneja la solicitud y emite un evento al backend | 1. El microservicio de Gestión de Recomendaciones maneja el botón |
| Modelo de Coordinación | Coordinación de la recomendación de artistas basada en las valoraciones del usuario | 1. El microservicio de Recomendaciones consulta directamente las valoraciones del usuario en el backend, 2. El microservicio de Recomendaciones mantiene un perfil del usuario basado en sus valoraciones previas y realiza recomendaciones sin necesidad de consultar constantemente las valoraciones, 3. El microservicio de Recomendaciones recibe eventos de valoraciones emitidos por el microservicio de Valoración Musical para actualizar el perfil del usuario y generar recomendaciones dinámicamente | 3. El microservicio de Recomendaciones recibe eventos de valoraciones emitidos por el microservicio de Valoración Musical para actualizar el perfil del usuario y generar recomendaciones dinámicamente |
| Modelo de Coordinación | Coordinación de la generación de recomendaciones personalizadas | 1. El microservicio de Recomendaciones usa un algoritmo de filtrado colaborativo basado en las interacciones de usuarios similares, 2. El microservicio de Recomendaciones utiliza un perfil explícito del usuario basado en sus preferencias de género y artistas previos, 3. El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario | 3. El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario |
| Modelo de Coordinación | Coordinación de la actualización de las recomendaciones en tiempo real | 1. El microservicio de Recomendaciones realiza la actualización de recomendaciones de forma síncrona con cada acción de valoración del usuario, 2. El microservicio de Recomendaciones utiliza un mecanismo de actualización en segundo plano para recalcular las recomendaciones, notificando al frontend cuando las recomendaciones están listas, 3. El microservicio de Recomendaciones emite eventos de actualización de recomendaciones que son consumidos por un servicio de cache para actualizar las recomendaciones en tiempo real sin recálculos completos | 2. El microservicio de Recomendaciones utiliza un mecanismo de actualización en segundo plano para recalcular las recomendaciones, notificando al frontend cuando las recomendaciones están listas |
| Modelo de Datos | Representación de las recomendaciones como entidad independiente | 1. Generación dinámica sin persistencia, 2. Entidad persistente de recomendaciones | 2. Entidad persistente de recomendaciones |
| Mapeo entre elementos de Arquitectura | Mapeo del modelo de recomendaciones personalizadas a las colecciones de MongoDB | 1. Mapeo directo con colección exclusiva para recomendaciones, 2. Incrustar recomendaciones dentro del documento del usuario | 1. Mapeo directo con colección exclusiva para recomendaciones |
| Elección de Tecnología | Elección de Tecnología para el Módulo de Recomendaciones Personalizadas en Singletone | 1. Modelo de Machine Learning Propio, 2. API basada en LLM | Modelo de Machine Learning Propio |


## Módulo 06: