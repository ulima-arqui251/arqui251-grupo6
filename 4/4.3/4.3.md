# 4.3. Modelo de Datos

## 00: Decisiones generales

### Decisión 1:
**Título:**
- Estrategia general de persistencia de datos.

**Contexto:**
La plataforma Singletone manejará diversos tipos de datos, incluyendo información de usuarios, perfiles, artistas, álbumes, canciones, valoraciones, listas de albums y la gestión de suscripciones. Es crucial definir una estrategia general para la persistencia de estos datos que considere la estructura, las relaciones, los requisitos de consulta y la escalabilidad.

**Alternativas:**
1. **Utilizar una única base de datos relacional (SQL):**
    - Almacenar todos los datos en una única base de datos con tablas relacionadas.
    - Ofrece consistencia ACID y soporte para consultas complejas mediante SQL.
    - Puede presentar desafíos de escalabilidad horizontal para grandes volúmenes de datos y alta concurrencia.
    - Adecuado para datos con relaciones bien definidas y requisitos de consistencia fuertes.

2. **Utilizar múltiples bases de datos relacionales (SQL) segregadas por microservicio:**
    - Cada microservicio tendría su propia base de datos relacional.
    - Mejora el aislamiento y la escalabilidad a nivel de microservicio.
    - Requiere estrategias para mantener la consistencia de datos a través de múltiples bases de datos (ej. Sagas, eventos).

3. **Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orientada a documentos y clave-valor:**
    - Emplear bases de datos SQL para datos relacionales y transaccionales (ej. gestión de usuarios, suscripciones).
    - Utilizar bases de datos NoSQL orientadas a documentos (ej. MongoDB) para datos no relacionales como metadatos de artistas, álbumes y canciones.
	- Integrar una base de datos clave-valor (ej. Redis) para almacenar datos de acceso frecuente o temporal, como el control de valoraciones semanales del usuario "free" y gestión rápida de valores booleanos
	- Requiere definir claramente qué tipo de datos se almacena en cada sistema y cómo se gestiona la coherencia entre ellos.

**Criterios de elección:**
- **Estructura de los Datos:** La naturaleza relacional o no relacional de los datos.
- **Consistencia:** Los requisitos de consistencia ACID para diferentes tipos de datos.
- **Escalabilidad:** La capacidad de manejar el crecimiento del volumen de datos y la concurrencia.
- **Rendimiento de Consulta:** La eficiencia de las consultas para los casos de uso principales.
- **Complejidad Operacional:** La dificultad de gestionar múltiples sistemas de persistencia.

**Decisión:**
Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orienda a documentos y clave-valor.

**Sustento:**
La información de usuarios y suscripciones se beneficia de la consistencia y las transacciones que ofrecen las bases de datos relacionales. Los metadatos musicales y las valoraciones pueden escalar mejor y ofrecer mayor flexibilidad con un modelo de datos no relacional como MongoDB. Además, Redis se incorpora para mejorar el rendimiento y reducir la latencia en el acceso a datos efímeros o muy consultados, como el control de valoraciones del usuario "free" o los datos booleanos. Esta estrategia híbrida permite optimizar el almacenamiento según el tipo y uso de los datos, equilibrando robustez, flexibilidad y velocidad.


## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- { Modelo de Datos para Entidad Usuario y Estructura de Plan de Suscripción }

**Contexto:**  
{ El sistema requiere almacenar información de usuarios registrados, incluyendo sus datos personales y el tipo de plan. Esta información debe ser usada en procesos como autenticación, visualización de perfil y control de acceso a funcionalidades premium, por lo que es necesario decidir cómo modelar esta información en la base de datos. }

**Alternativas:**
1. **Modelo relacional normalizado (SQL)**
     - {Uso de múltiples tablas con relaciones bien definidas (por ejemplo, usuarios, planes).}
     - {Soporte nativo para claves primarias y foráneas (integridad referencial).}
     - {Cumple con principios de normalización (1FN, 2FN, 3FN).}
     - {Consistencia fuerte de los datos.}
     - {Uso común en sistemas que requieren control estricto de datos (como autenticación y suscripciones).}
     - {Requiere definiciones explícitas para cambios de esquema.}
     - {Posibilidad de usar ORMs como Sequelize, TypeORM, etc.}

2. **Modelo documental (NoSQL – MongoDB, etc.)**
     - {Representación de datos como documentos JSON embebidos (usuario y plan en un mismo documento).}
     - {Alta flexibilidad en la estructura de datos (sin esquema fijo).}
     - {No ofrece integridad referencial de forma nativa.}
     - {Mejor rendimiento en consultas simples (sin necesidad de joins).}
     - {Menor complejidad de configuración inicial.}
     - {Escalable horizontalmente de forma sencilla.}
     - {Los cambios de estructura no requieren migraciones formales (esquema dinámico).}
     
**Criterios de elección:**
- **Escalabilidad:** { Capacidad de modificar y ampliar el sistema con mas componentes en el tiempo }
- **Mantenibilidad:** { Capacidad de mantener el sistema actualizado en el tiempo. }
- **{ Flexibilidad futura }:** { Habilidad del modelo de adaptarse fácilmente a nuevos requerimientos sin rediseñar la estructura de datos. }

**Decisión:**
{ Se elige alternativa 1 }

**Sustento:**
{El módulo de gestión de usuarios necesita validar datos como correo, nickname y tipo de cuenta. Un modelo relacional permite garantizar que estas reglas se respeten mediante claves únicas, claves foráneas y restricciones a nivel de base de datos. El modelo relacional permite mayor flexibilidad respecto a los planes de suscripción, permitiendo modificarlos o añadir nuevos sin afectar el sistema ya existente.}


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- { Estructura de datos para representar la información del perfil del usuario }

**Contexto:**  
{ El perfil del usuario debe incluir tres tipos de datos: Personales, Estadísticas y Biblioteca musical. La definición del modelo de datos debe facilitar el acceso eficiente a esta información y permitir su crecimiento si se agregan nuevas métricas o contenidos en el futuro. }

**Alternativas:**
1. **Modelo separado por dominios (composición de modelos especializados)**
     - {Se define un modelo PerfilUsuario que se compone de tres submodelos: DatosBasicos, EstadisticasUsuario y BibliotecaMusical}
     - {Claramente delimitados los datos que provienen de distintos módulos.}
     - {Escalable y fácilmente extensible por secciones.}
     - {Facilita el testing y la separación de responsabilidades.}

2. **Modelo monolítico de perfil unificado**
     - {Toda la información del perfil se agrupa en un solo objeto PerfilUsuario.}
     - {Estructura plana con todos los campos juntos.}
     - {Más simple de implementar inicialmente.}
     - {Puede volverse difícil de mantener a medida que crece el número de atributos.}
     
**Criterios de elección:**
- **Escalabilidad:** { Facilidad para agregar nuevas secciones, atributos o métricas en el futuro. }
- **Legibilidad:** { Claridad del modelo al momento de entender, mantener y modificar el código. }
- **{ Desacoplamiento }:** { Nivel de independencia entre los distintos dominios de datos del perfil. }

**Decisión:**
{ Se elige la Alternativa 1 }

**Sustento:**
{ Dado que la información del perfil proviene de distintos módulos funcionales (usuarios, monetización, biblioteca), resulta más mantenible y escalable estructurar los datos de manera modular. Esto permite modificar o extender secciones específicas (por ejemplo, agregar nuevas métricas estadísticas o cambiar la forma en que se calculan ponderados musicales) sin afectar al resto del modelo. También facilita el reuso de submodelos en otras partes del sistema o en futuras versiones de la vista de perfil. }



## 03: Exploración musical

### Decisión 1:
**Título:**
- Uso de base de datos orientada a documentos para soportar búsquedas flexibles y de alto rendimiento.

**Contexto:**  
El módulo 03 necesita realizar búsquedas rápidas y flexibles de diferentes tipos de entidades, cada una con estructuras de datos variables. Ante esto, se deben poder filtrar por nombre, tipo, categoría, y retornar resultados de manera eficiente, además de que se pueda manejar los grandes volúmenes de resultados sin tiempos de carga prolongados.

**Alternativas:**
1. **Alternativa 01:**
     - Usar una base de datos relacional SQL que permita fijar tablas y relaciones

2. **Alternativa 02:**
     - Usar una base de datos NoSQL orientada a documentos JSON que almacene estructuras variables
     
3. **Alternativa 03:**
     - Usar un motor de búsqueda especializado que permita búsquedas de texto completo y ranking de resultados

**Criterios de elección:**
- **Escalabilidad:** Se favorecerá la opción que tenga la capacidad de crecer en volumen de datos y usuarios de forma rápida
- **Mantenibilidad:** Se buscará la facilidad por desarrollo y administración del equipo actual
- **Flexibilidad:** Se valorará la capacidad de almacenar diferentes estructuras de datos sin rigidez
- **Rendimiento:** Se priorizará por la elección que aumente la velocidad de búsquedas por nombre, categoría y tipo

**Decisión:**
Se opta por utilizar una base de datos NoSQL orientada a documentos, específicamente MongoDB, para almacenar y consultar álbumes, artistas y usuarios de forma flexible y eficiente.

**Sustento:**
MongoDB permite manejar estructuras de datos variables y realizar búsquedas rápidas por nombre o categoría, que son las principales interacciones del módulo 03. Además, su capacidad de escalar horizontalmente y su compatibilidad con consultas sobre documentos JSON lo hacen ideal para soportar el crecimiento esperado de usuarios y contenido en la plataforma. Esta elección mejora el rendimiento sin sacrificar la simplicidad y la mantenibilidad del sistema.


## 04: Gestión de biblioteca

### Decisión 1:
**Título:**
- Estructura de datos para la biblioteca del usuario.

**Contexto:**
Cada usuario tendrá una biblioteca personal que contendrá artistas y álbumes agregados, junto con el estado de valoración de estos. Es necesario definir cómo se organizarán estos datos para permitir consultas eficientes (ej. listar todos los álbumes, listar artistas por estado de valoración).

**Alternativas:**
1. **Almacenar la biblioteca como una lista de referencias en el documento del usuario (en MongoDB):**
    - El documento del usuario en MongoDB contendría arrays de IDs de artistas y álbumes agregados, posiblemente con información adicional sobre su estado de valoración.
    - Simple para agregar y consultar la biblioteca de un usuario específico.
    - Podría volverse ineficiente para consultas que involucren a múltiples usuarios o para filtrar por el estado de valoración a nivel global.

2. **Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado:**
    - Se tendrían colecciones como `user_artists` (userId, artistId, estado) y `user_albums` (userId, albumId, estado).
    - Permite consultas más eficientes para filtrar por estado o para obtener todos los usuarios que tienen un cierto artista o álbum en su biblioteca.
    - Requiere más joins lógicos a nivel de aplicación para reconstruir la biblioteca completa de un usuario.

3. **Utilizar tablas relacionales (en PostgreSQL) para las relaciones usuario-artista y usuario-álbum con información de estado:**
    - Se crearían tablas como `user_artists` (user_id, artist_id, estado) y `user_albums` (user_id, album_id, estado) en PostgreSQL.
    - Permite joins eficientes y consultas complejas utilizando SQL.
    - Podría ser menos flexible para almacenar metadatos adicionales específicos de la relación usuario-artista/álbum.

**Decisión:**
Crear colecciones separadas en MongoDB para las relaciones usuario-artista (`user_artists`) y usuario-álbum (`user_albums`), cada una conteniendo `userId`, `artistId` o `albumId`, y un campo `estado` para indicar si están "agregado" o "valorado".

**Sustento:**
Esta estructura permite consultas eficientes para obtener la biblioteca de un usuario específico filtrando por `userId`. Además, facilita las consultas para listar todos los artistas o álbumes en la biblioteca de los usuarios y filtrar por su estado. Aunque requiere dos consultas separadas para obtener la lista completa de artistas y álbumes de un usuario, la flexibilidad y el rendimiento para los casos de uso principales (visualización del perfil, navegación por la biblioteca) se ven optimizados.

### Decisión 2:
**Título:**
- Estructura de datos para las valoraciones de álbumes y canciones.

**Contexto:**
Los usuarios pueden valorar individualmente cada canción de un álbum. Es necesario definir cómo se almacenarán estas valoraciones, considerando la relación con el usuario, el álbum y la canción, así como la fecha de valoración.

**Alternativas:**
1. **Incorporar las valoraciones como un subdocumento dentro del documento del álbum en la biblioteca del usuario (en MongoDB):**
    - Dentro del documento `user_albums`, se podría tener un array de subdocumentos que contengan `cancionId` y `puntuacion`.
    - Facilita el acceso a las valoraciones de un álbum específico para un usuario.
    - Podría volverse ineficiente para consultas sobre las valoraciones de una canción específica a través de múltiples usuarios o álbumes.

2. **Crear una colección separada de "Valoraciones" en MongoDB:**
    - Una colección `valoraciones` con documentos que contengan `userId`, `albumId`, `cancionId`, `puntuacion` y `fechaValoracion`.
    - Permite consultas flexibles para obtener valoraciones por usuario, álbum, canción o rango de fechas.
    - Requiere joins lógicos a nivel de aplicación para relacionar las valoraciones con los usuarios, álbumes y canciones.

3. **Utilizar tablas relacionales (en PostgreSQL) para almacenar las valoraciones:**
    - Una tabla `valoraciones` con columnas como `user_id`, `album_id`, `cancion_id`, `puntuacion` y `fecha_valoracion`.
    - Permite joins eficientes y consultas complejas utilizando SQL.
    - Podría ser menos flexible para almacenar metadatos adicionales sobre la valoración en el futuro.

**Decisión:**
Crear una colección separada de "Valoraciones" en MongoDB con documentos que contengan `userId`, `albumId`, `cancionId`, `puntuacion` (un entero), y `fechaValoracion` (un timestamp).

**Sustento:**
Esta estructura ofrece la mayor flexibilidad para las consultas sobre las valoraciones. Permite buscar fácilmente todas las valoraciones de un usuario, las valoraciones de un álbum específico, o las valoraciones de una canción en particular. La separación en una colección dedicada facilita la escalabilidad y el manejo de un gran volumen de datos de valoración. Aunque requiere joins lógicos a nivel de aplicación para reconstruir la información completa, los beneficios en términos de flexibilidad de consulta y escalabilidad son significativos.

### Decisión 3:
**Título:**
- Metadatos para artistas, álbumes y canciones.

**Contexto:**
Se necesita almacenar información detallada sobre los artistas (nombre, foto/logo), los álbumes (nombre, portada, año de salida, tracklist) y las canciones (nombre). Estos metadatos serán utilizados en la exploración musical, la visualización de perfiles y la gestión de la biblioteca.

**Alternativas:**
1. **Almacenar todos los metadatos en una única colección "Música" en MongoDB:**
    - Una colección con documentos que incluyan el tipo (artista, álbum, canción) y los atributos específicos para cada tipo.
    - Simplifica la estructura inicial.
    - Podría volverse complejo para realizar consultas específicas por tipo o por atributo.

2. **Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones":**
    - `artistas`: `_id`, `nombre`, `fotoUrl`.
    - `albums`: `_id`, `artistaId` (fk), `nombre`, `portadaUrl`, `añoSalida`, `tracklist` (array de nombres de canciones).
    - `canciones`: `_id`, `albumId` (fk), `nombre`.
    - Permite una organización clara y consultas eficientes por tipo de entidad.
    - Establece relaciones explícitas entre las entidades.

3. **Utilizar tablas relacionales (en PostgreSQL) para almacenar los metadatos:**
    - Tablas `artistas`, `albums` (con clave foránea a `artistas`), y `canciones` (con clave foránea a `albums`).
    - Permite relaciones bien definidas y consultas complejas utilizando SQL.
    - Podría ser menos flexible para la evolución de los metadatos si se necesitan agregar nuevos campos con frecuencia.

**Decisión:**
Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones"

**Sustento:**
Esta estructura proporciona una organización clara de los metadatos y facilita las consultas específicas por tipo de entidad. El uso de referencias (`artistaId`, `albumId`) permite establecer las relaciones necesarias entre las entidades, lo que es crucial para la exploración musical y la visualización de detalles. MongoDB ofrece la flexibilidad necesaria para adaptar las estructuras de los documentos si se necesitan agregar nuevos metadatos en el futuro.


## 05: Gestión de recomendaciones

### Decisión 1:
**Título:**
- Uso de base de datos orientada a documentos para gestionar recomendaciones dinámicas.

**Contexto:**  
El módulo de recomendaciones debe ser capaz de generar recomendaciones personalizadas y dinámicas para los usuarios basadas en su historial de interacción con la plataforma. Estas recomendaciones deben poder actualizarse en tiempo real conforme los usuarios interactúan con el sistema, lo que implica manejar datos estructurados de manera flexible y eficiente.

**Alternativas:**
1. **Alternativa 01:**
   - Utilizar una base de datos relacional SQL que mantenga tablas fijas para almacenar los datos de usuario y recomendaciones.
   
2. **Alternativa 02:**
   - Utilizar una base de datos NoSQL orientada a documentos que pueda almacenar datos variables, permitiendo flexibilidad en la actualización y consulta de las recomendaciones.

3. **Alternativa 03:**
   - Implementar un motor de recomendación independiente que procese y almacene datos en memoria, haciendo las recomendaciones sin una base de datos persistente.

**Criterios de elección:**
- **Escalabilidad:** Necesitamos una solución que sea capaz de escalar con el aumento de usuarios y sus interacciones.
- **Flexibilidad:** La capacidad de gestionar datos no estructurados y diferentes tipos de interacciones (historial de escucha, valoraciones, etc.).
- **Rendimiento:** Optimización para consultas rápidas y generación en tiempo real de recomendaciones personalizadas.
- **Mantenibilidad:** Facilidad para integrar cambios y nuevas fuentes de datos sin complicaciones.

**Decisión:**
Se opta por utilizar una base de datos NoSQL orientada a documentos, específicamente MongoDB, para almacenar y consultar datos de usuarios y sus recomendaciones de manera eficiente y flexible.

**Sustento:**
MongoDB permite manejar estructuras de datos flexibles y dinámicas, lo que es ideal para gestionar los datos de usuario y sus preferencias cambiantes. Al ser una base de datos NoSQL orientada a documentos, facilita el almacenamiento de interacciones variables y se adapta fácilmente al crecimiento de los datos y a la necesidad de realizar consultas rápidas para obtener recomendaciones en tiempo real. Además, su capacidad de escalar horizontalmente es clave para soportar una mayor carga de usuarios e interacciones en la plataforma.


## 05: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

