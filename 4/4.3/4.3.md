# 4.3. Modelo de Datos

## 00: Decisiones generales

### Decisión 1:
**Título:**
- Estrategia general de persistencia de datos.

**Contexto:**
La plataforma Singletone manejará diversos tipos de datos, incluyendo información de usuarios, perfiles, artistas, álbumes, canciones, valoraciones, listas de albums y la gestión de suscripciones. Es crucial definir una estrategia general para la persistencia de estos datos que considere la estructura, las relaciones, los requisitos de consulta y la escalabilidad.

**Alternativas:**
1. **Utilizar una única base de datos relacional (SQL):**
    - Almacenar todos los datos en una única base de datos con tablas relacionadas.
    - Ofrece consistencia ACID y soporte para consultas complejas mediante SQL.
    - Puede presentar desafíos de escalabilidad horizontal para grandes volúmenes de datos y alta concurrencia.
    - Adecuado para datos con relaciones bien definidas y requisitos de consistencia fuertes.

2. **Utilizar múltiples bases de datos relacionales (SQL) segregadas por microservicio:**
    - Cada microservicio tendría su propia base de datos relacional.
    - Mejora el aislamiento y la escalabilidad a nivel de microservicio.
    - Requiere estrategias para mantener la consistencia de datos a través de múltiples bases de datos (ej. Sagas, eventos).

3. **Utilizar una combinación de bases de datos relacionales (SQL) y NoSQL:**
    - Emplear bases de datos SQL para datos relacionales y transaccionales (ej. gestión de usuarios, suscripciones).
    - Utilizar bases de datos NoSQL (ej. MongoDB, Cassandra) para datos no relacionales o con requisitos de alta escalabilidad y disponibilidad (ej. valoraciones, recomendaciones, metadatos de artistas y álbumes).
    - Requiere definir claramente qué tipo de datos se almacena en cada sistema y cómo se gestiona la coherencia entre ellos.

**Criterios de elección:**
- **Estructura de los Datos:** La naturaleza relacional o no relacional de los datos.
- **Consistencia:** Los requisitos de consistencia ACID para diferentes tipos de datos.
- **Escalabilidad:** La capacidad de manejar el crecimiento del volumen de datos y la concurrencia.
- **Rendimiento de Consulta:** La eficiencia de las consultas para los casos de uso principales.
- **Complejidad Operacional:** La dificultad de gestionar múltiples sistemas de persistencia.

**Decisión:**
Utilizar una combinación de bases de datos relacionales (PostgreSQL) para la gestión de usuarios y suscripciones, y una base de datos NoSQL orientada a documentos (MongoDB) para el almacenamiento de metadatos de artistas, álbumes, canciones y valoraciones.

**Sustento:**
La información de usuarios y suscripciones se beneficia de la consistencia y las transacciones que ofrecen las bases de datos relacionales. Por otro lado, los metadatos musicales y las valoraciones pueden escalar mejor y ofrecer mayor flexibilidad con un modelo de datos no relacional. PostgreSQL proporcionará la robustez necesaria para los datos críticos, mientras que MongoDB permitirá una mayor flexibilidad en la estructura de los documentos y una mejor escalabilidad para los datos con alta rotación y volumen.


## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 03: Exploración musical

### Decisión 1:
**Título:**
- Estructura de datos para la biblioteca del usuario.

**Contexto:**
Cada usuario tendrá una biblioteca personal que contendrá artistas y álbumes agregados, junto con el estado de valoración de estos. Es necesario definir cómo se organizarán estos datos para permitir consultas eficientes (ej. listar todos los álbumes, listar artistas por estado de valoración).

**Alternativas:**
1. **Almacenar la biblioteca como una lista de referencias en el documento del usuario (en MongoDB):**
    - El documento del usuario en MongoDB contendría arrays de IDs de artistas y álbumes agregados, posiblemente con información adicional sobre su estado de valoración.
    - Simple para agregar y consultar la biblioteca de un usuario específico.
    - Podría volverse ineficiente para consultas que involucren a múltiples usuarios o para filtrar por el estado de valoración a nivel global.

2. **Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado:**
    - Se tendrían colecciones como `user_artists` (userId, artistId, estado) y `user_albums` (userId, albumId, estado).
    - Permite consultas más eficientes para filtrar por estado o para obtener todos los usuarios que tienen un cierto artista o álbum en su biblioteca.
    - Requiere más joins lógicos a nivel de aplicación para reconstruir la biblioteca completa de un usuario.

3. **Utilizar tablas relacionales (en PostgreSQL) para las relaciones usuario-artista y usuario-álbum con información de estado:**
    - Se crearían tablas como `user_artists` (user_id, artist_id, estado) y `user_albums` (user_id, album_id, estado) en PostgreSQL.
    - Permite joins eficientes y consultas complejas utilizando SQL.
    - Podría ser menos flexible para almacenar metadatos adicionales específicos de la relación usuario-artista/álbum.

**Decisión:**
Crear colecciones separadas en MongoDB para las relaciones usuario-artista (`user_artists`) y usuario-álbum (`user_albums`), cada una conteniendo `userId`, `artistId` o `albumId`, y un campo `estado` para indicar si están "agregado" o "valorado".

**Sustento:**
Esta estructura permite consultas eficientes para obtener la biblioteca de un usuario específico filtrando por `userId`. Además, facilita las consultas para listar todos los artistas o álbumes en la biblioteca de los usuarios y filtrar por su estado. Aunque requiere dos consultas separadas para obtener la lista completa de artistas y álbumes de un usuario, la flexibilidad y el rendimiento para los casos de uso principales (visualización del perfil, navegación por la biblioteca) se ven optimizados.

### Decisión 2:
**Título:**
- Estructura de datos para las valoraciones de álbumes y canciones.

**Contexto:**
Los usuarios pueden valorar individualmente cada canción de un álbum. Es necesario definir cómo se almacenarán estas valoraciones, considerando la relación con el usuario, el álbum y la canción, así como la fecha de valoración.

**Alternativas:**
1. **Incorporar las valoraciones como un subdocumento dentro del documento del álbum en la biblioteca del usuario (en MongoDB):**
    - Dentro del documento `user_albums`, se podría tener un array de subdocumentos que contengan `cancionId` y `puntuacion`.
    - Facilita el acceso a las valoraciones de un álbum específico para un usuario.
    - Podría volverse ineficiente para consultas sobre las valoraciones de una canción específica a través de múltiples usuarios o álbumes.

2. **Crear una colección separada de "Valoraciones" en MongoDB:**
    - Una colección `valoraciones` con documentos que contengan `userId`, `albumId`, `cancionId`, `puntuacion` y `fechaValoracion`.
    - Permite consultas flexibles para obtener valoraciones por usuario, álbum, canción o rango de fechas.
    - Requiere joins lógicos a nivel de aplicación para relacionar las valoraciones con los usuarios, álbumes y canciones.

3. **Utilizar tablas relacionales (en PostgreSQL) para almacenar las valoraciones:**
    - Una tabla `valoraciones` con columnas como `user_id`, `album_id`, `cancion_id`, `puntuacion` y `fecha_valoracion`.
    - Permite joins eficientes y consultas complejas utilizando SQL.
    - Podría ser menos flexible para almacenar metadatos adicionales sobre la valoración en el futuro.

**Decisión:**
Crear una colección separada de "Valoraciones" en MongoDB con documentos que contengan `userId`, `albumId`, `cancionId`, `puntuacion` (un entero), y `fechaValoracion` (un timestamp).

**Sustento:**
Esta estructura ofrece la mayor flexibilidad para las consultas sobre las valoraciones. Permite buscar fácilmente todas las valoraciones de un usuario, las valoraciones de un álbum específico, o las valoraciones de una canción en particular. La separación en una colección dedicada facilita la escalabilidad y el manejo de un gran volumen de datos de valoración. Aunque requiere joins lógicos a nivel de aplicación para reconstruir la información completa, los beneficios en términos de flexibilidad de consulta y escalabilidad son significativos.

### Decisión 3:
**Título:**
- Metadatos para artistas, álbumes y canciones.

**Contexto:**
Se necesita almacenar información detallada sobre los artistas (nombre, foto/logo), los álbumes (nombre, portada, año de salida, tracklist) y las canciones (nombre). Estos metadatos serán utilizados en la exploración musical, la visualización de perfiles y la gestión de la biblioteca.

**Alternativas:**
1. **Almacenar todos los metadatos en una única colección "Música" en MongoDB:**
    - Una colección con documentos que incluyan el tipo (artista, álbum, canción) y los atributos específicos para cada tipo.
    - Simplifica la estructura inicial.
    - Podría volverse complejo para realizar consultas específicas por tipo o por atributo.

2. **Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones":**
    - `artistas`: `_id`, `nombre`, `fotoUrl`.
    - `albums`: `_id`, `artistaId` (fk), `nombre`, `portadaUrl`, `añoSalida`, `tracklist` (array de nombres de canciones).
    - `canciones`: `_id`, `albumId` (fk), `nombre`.
    - Permite una organización clara y consultas eficientes por tipo de entidad.
    - Establece relaciones explícitas entre las entidades.

3. **Utilizar tablas relacionales (en PostgreSQL) para almacenar los metadatos:**
    - Tablas `artistas`, `albums` (con clave foránea a `artistas`), y `canciones` (con clave foránea a `albums`).
    - Permite relaciones bien definidas y consultas complejas utilizando SQL.
    - Podría ser menos flexible para la evolución de los metadatos si se necesitan agregar nuevos campos con frecuencia.

**Decisión:**
Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones"

**Sustento:**
Esta estructura proporciona una organización clara de los metadatos y facilita las consultas específicas por tipo de entidad. El uso de referencias (`artistaId`, `albumId`) permite establecer las relaciones necesarias entre las entidades, lo que es crucial para la exploración musical y la visualización de detalles. MongoDB ofrece la flexibilidad necesaria para adaptar las estructuras de los documentos si se necesitan agregar nuevos metadatos en el futuro.



## 04: Gestión de biblioteca

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de recomendaciones

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

