# 4.5. Elección de Tecnología

## 00: Decisiones generales

### Decisión 1:
**Título:**
- Tecnología para el desarrollo del Frontend.

**Contexto:**
La interfaz de usuario de Singletone debe ser dinámica, reactiva y ofrecer una buena experiencia de usuario en diferentes dispositivos. La elección del framework o librería de frontend es crucial para la productividad del equipo de desarrollo y la calidad de la aplicación.

**Alternativas:**
1. **React:**
    - Librería de JavaScript para construir interfaces de usuario interactivas y declarativas basadas en componentes.
    - Amplia comunidad, gran cantidad de librerías y herramientas disponibles.
    - Alto rendimiento gracias al Virtual DOM.
    - Curva de aprendizaje moderada.
    - Permite la creación de Single Page Applications (SPAs) que ofrecen una experiencia fluida.

2. **Angular:**
    - Framework de desarrollo de aplicaciones web completo, basado en TypeScript.
    - Arquitectura bien definida y robusta.
    - Curva de aprendizaje más pronunciada que React.
    - Ideal para aplicaciones complejas y de gran escala.

3. **Vue.js:**
    - Framework progresivo de JavaScript para construir interfaces de usuario.
    - Sintaxis clara y concisa, fácil de aprender.
    - Buen rendimiento y flexibilidad.
    - Comunidad en crecimiento, aunque más pequeña que React y Angular.

**Criterios de elección:**
- **Experiencia del Equipo:** Familiaridad del equipo de desarrollo con la tecnología.
- **Rendimiento:** La capacidad de la tecnología para ofrecer una experiencia de usuario rápida y fluida.
- **Comunidad y Ecosistema:** Disponibilidad de documentación, librerías y soporte.
- **Flexibilidad:** La capacidad de la tecnología para adaptarse a los requisitos del proyecto.

**Decisión:**
React.

**Sustento:**
Dado que ya se ha planeado utilizar React, esta decisión se alinea con esa elección. React cuenta con una amplia comunidad, un amplio ecosistema de librerías y herramientas, y es adecuado para construir las interfaces dinámicas e interactivas que Singletone requiere. Su arquitectura basada en componentes facilita la organización y el mantenimiento del código, y su rendimiento es óptimo para SPAs.

### Decisión 2:
**Título:**
- Tecnología para el desarrollo del Backend.

**Contexto:**
El backend de Singletone debe ser capaz de manejar las solicitudes de los usuarios, interactuar con las bases de datos, implementar la lógica de negocio y exponer APIs para el frontend. La elección del entorno de ejecución y el framework es fundamental para el rendimiento, la escalabilidad y la productividad del equipo de backend.

**Alternativas:**
1. **Node.js con Express.js:**
    - Entorno de ejecución de JavaScript en el servidor, con un framework minimalista y flexible (Express.js) para construir APIs.
    - Permite utilizar JavaScript tanto en el frontend como en el backend, facilitando la colaboración entre equipos.
    - Gran ecosistema de paquetes (npm) y una comunidad activa.
    - Buen rendimiento para aplicaciones I/O intensivas.

2. **Python con Django o Flask:**
    - Lenguaje de programación versátil con frameworks robustos para el desarrollo web (Django - más completo, Flask - más ligero).
    - Amplia adopción en la industria y una gran cantidad de librerías disponibles.
    - Buen rendimiento y escalabilidad.

3. **Java con Spring Boot:**
    - Plataforma robusta y escalable para construir aplicaciones empresariales.
    - Amplio ecosistema y una gran comunidad.
    - Curva de aprendizaje más pronunciada que Node.js o Python.

**Criterios de elección:**
- **Experiencia del Equipo:** Familiaridad del equipo de desarrollo con la tecnología.
- **Rendimiento:** La capacidad de la tecnología para manejar la carga de usuarios esperada.
- **Escalabilidad:** La facilidad para escalar la aplicación a medida que crece la base de usuarios.
- **Comunidad y Ecosistema:** Disponibilidad de documentación, librerías y soporte.

**Decisión:**
Node.js con Express.js.

**Sustento:**
Dado que ya se ha planeado utilizar Node.js, esta decisión se alinea con esa elección. Node.js permite a los desarrolladores utilizar JavaScript en ambos lados de la aplicación, lo que puede mejorar la eficiencia del desarrollo. Su arquitectura orientada a eventos y su naturaleza no bloqueante lo hacen adecuado para manejar un gran número de conexiones concurrentes, lo cual es importante para una plataforma web como Singletone. Express.js proporciona un framework flexible y minimalista para construir las APIs necesarias.

### Decisión 3:
**Título:**
- Tecnología para la base de datos relacional.

**Contexto:**
Se ha decidido utilizar una base de datos relacional para la gestión de usuarios y suscripciones, donde la consistencia y las transacciones ACID son importantes.

**Alternativas:**
1. **PostgreSQL:**
    - Sistema de gestión de bases de datos relacional de código abierto, potente y extensible.
    - Cumple con los estándares SQL, ofrece características avanzadas y es altamente confiable.
    - Amplia comunidad y buen soporte.

2. **MySQL:**
    - Sistema de gestión de bases de datos relacional de código abierto, ampliamente utilizado.
    - Fácil de usar y con una gran cantidad de documentación y herramientas.

3. **MariaDB:**
    - Fork de MySQL mantenido por la comunidad, con mejoras de rendimiento y características adicionales.

**Criterios de elección:**
- **Confiabilidad y Estabilidad:** La robustez de la base de datos para garantizar la integridad de los datos.
- **Características:** Las funcionalidades ofrecidas por el sistema de base de datos (ej. transacciones, concurrencia).
- **Rendimiento:** La eficiencia en la lectura y escritura de datos.
- **Comunidad y Soporte:** Disponibilidad de documentación y ayuda.

**Decisión:**
PostgreSQL.

**Sustento:**
Dado que ya se ha planeado utilizar PostgreSQL, esta decisión se alinea con esa elección. PostgreSQL es una base de datos relacional robusta y confiable que cumple con los requisitos de consistencia y transaccionalidad necesarios para la gestión de usuarios y suscripciones en Singletone. Su amplia gama de características y su activa comunidad lo convierten en una excelente opción.

### Decisión 4:
**Título:**
- Tecnología para la base de datos NoSQL.

**Contexto:**
Se ha decidido utilizar una base de datos NoSQL para el almacenamiento de metadatos de artistas, álbumes, canciones y valoraciones, donde la flexibilidad del esquema y la escalabilidad son importantes.

**Alternativas:**
1. **MongoDB:**
    - Base de datos NoSQL orientada a documentos, que almacena datos en formato JSON-like (BSON).
    - Esquema flexible, fácil de escalar horizontalmente.
    - Buen rendimiento para casos de uso de lectura y escritura intensivas.

2. **Cassandra:**
    - Base de datos NoSQL distribuida y altamente escalable, diseñada para alta disponibilidad.
    - Modelo de datos basado en columnas.
    - Ideal para grandes volúmenes de datos con requisitos de alta disponibilidad.

3. **Couchbase:**
    - Base de datos NoSQL que combina características de bases de datos de documentos y clave-valor, con capacidades de almacenamiento en caché integradas.

**Criterios de elección:**
- **Flexibilidad del Esquema:** La facilidad para adaptar la estructura de los datos.
- **Escalabilidad:** La capacidad de manejar grandes volúmenes de datos y alta concurrencia.
- **Rendimiento:** La eficiencia en la lectura y escritura de datos no relacionales.
- **Facilidad de Uso:** La curva de aprendizaje y la disponibilidad de herramientas.

**Decisión:**
MongoDB.

**Sustento:**
Dado que ya se ha planeado utilizar MongoDB, esta decisión se alinea con esa elección. MongoDB es una base de datos NoSQL orientada a documentos que ofrece la flexibilidad de esquema necesaria para los metadatos musicales y la escalabilidad horizontal requerida para las valoraciones. Su modelo de datos es intuitivo para representar estructuras jerárquicas como álbumes con sus canciones, y su rendimiento es adecuado para los casos de uso previstos.

### Decisión 5:
**Título:**
- Tecnología para la orquestación de contenedores.

**Contexto:**
Para facilitar el despliegue, la gestión y la escalabilidad de los microservicios de Singletone, se utilizará una plataforma de orquestación de contenedores.

**Alternativas:**
1. **Kubernetes:**
    - Plataforma de orquestación de contenedores de código abierto, ampliamente adoptada en la industria.
    - Ofrece una gran cantidad de características para la gestión de despliegues, escalado, balanceo de carga y auto-recuperación.
    - Gran comunidad y ecosistema.
    - Curva de aprendizaje significativa.

2. **Docker Swarm:**
    - Solución de orquestación nativa de Docker, más sencilla de configurar que Kubernetes.
    - Adecuada para despliegues más pequeños o equipos con menos experiencia en orquestación.

3. **Amazon ECS (Elastic Container Service):**
    - Servicio de orquestación de contenedores propietario de AWS, integrado con otros servicios de AWS.
    - Facilita la gestión de contenedores en la infraestructura de AWS.

**Criterios de elección:**
- **Escalabilidad:** La capacidad de escalar la aplicación de manera eficiente.
- **Facilidad de Gestión:** La complejidad de configurar y mantener la plataforma de orquestación.
- **Comunidad y Soporte:** Disponibilidad de documentación y ayuda.
- **Integración con la Infraestructura:** La compatibilidad con la infraestructura de despliegue planificada.

**Decisión:**
Kubernetes.

**Sustento:**
Dado que ya se ha planeado utilizar Kubernetes, esta decisión se alinea con esa elección. Kubernetes es la plataforma de orquestación de contenedores más popular y ofrece una gran cantidad de funcionalidades para la gestión de microservicios a escala. Aunque su curva de aprendizaje puede ser pronunciada, su robustez, escalabilidad y la gran comunidad que lo respalda lo convierten en una opción ideal para la arquitectura de microservicios de Singletone.


## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- { Elección del framework backend para el módulo de Gestión de Usuarios }

**Contexto:**  
{ El Módulo 1 gestiona el registro e inicio de sesión de usuarios, siendo clave para el acceso a la plataforma. Necesita integrarse con otros módulos como el de monetización, y requiere una tecnología backend que sea escalable, fácil de mantener y compatible con el frontend. Además, el equipo tiene experiencia en JavaScript, lo que influye en la elección tecnológica. }

**Alternativas:**
1. **Node.js con Express**
     - {Basado en JavaScript, lo cual permite compartir lenguaje con el frontend si se usa React/Vue.}
     - {Gran ecosistema de paquetes (npm), incluyendo autenticación (passport, jsonwebtoken, etc.).}
     - {Arquitectura minimalista y flexible.}
     - {Requiere configuración manual de muchas cosas (estructura, seguridad, middlewares).}

2. **Django (Python)**
     - {Framework de alto nivel con muchas funcionalidades incluidas (ORM, autenticación, formularios, panel admin).}
     - {Usa Python, un lenguaje legible y muy usado en contextos académicos y científicos.}
     - {Incluye seguridad y validaciones integradas.}
     - {Puede sentirse restrictivo para estructuras personalizadas o microservicios.}
     
**Criterios de elección:**
- **Escalabilidad:** { Qué tan bien se adapta la tecnología al crecimiento del sistema. }
- **Mantenibilidad:** { Capacidad de mantener el sistema actualizado en el tiempo. }
- **{ Fácil entrenamiento }:** { Qué tan rápido los nuevos desarrolladores pueden entender y trabajar con la tecnología. }

**Decisión:**
{ Se elige la alternativa 1 }

**Sustento:**
{ Node.js con Express ofrece una curva de aprendizaje baja, facilidad de integración con el frontend (si se utiliza React o similar), y una comunidad muy activa. Además, su arquitectura modular y su ecosistema permiten implementar autenticación y validación de usuarios con rapidez. Spring Boot es potente pero introduce una complejidad innecesaria para un módulo que no requiere aún la robustez de un entorno empresarial. Django es sólido, pero no encaja tan bien en un stack tecnológico basado en JavaScript, y su ORM puede ser limitante frente a soluciones más flexibles. }



## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- { Elección de la librería de visualización para los carruseles y gráficos en el perfil del usuario }

**Contexto:**  
{ El módulo de perfil presenta visualizaciones como carruseles de álbumes y artistas (ordenados por ponderado), así como secciones estadísticas. Es necesario decidir qué tecnología utilizar para implementar estas visualizaciones, priorizando una buena experiencia de usuario, facilidad de integración con el stack actual (React) y mantenibilidad. }

**Alternativas:**
1. **Uso de Swiper.js para carruseles + Recharts para estadísticas**
     - {Swiper.js permite carruseles con control táctil, soporte móvil y alto nivel de personalización.}
     - {Recharts ofrece integración sencilla con React y permite representar gráficas de barras o líneas con bajo esfuerzo.}
     - {Gran comunidad, documentación completa y buena compatibilidad.}

2. **Uso de Slick Carousel + Chart.js**
     - {Slick Carousel es una librería veterana para sliders con animaciones fluidas, aunque menos actualizada.}
     - {Chart.js ofrece visualizaciones robustas y altamente personalizables, pero su integración con React no es tan directa.}
     - {Comunidad estable, pero menor compatibilidad con tecnologías modernas como React hooks.}
     
**Criterios de elección:**
- **Compatibilidad con React:** { Qué tan bien se integran con React (hooks, componentes funcionales, SSR). }
- **Mantenibilidad:** { Nivel de documentación, frecuencia de actualizaciones y comunidad activa. }
- **{ Experiencia de usuario }:** { Qué tan fluidas y responsivas son las visualizaciones. }

**Decisión:**
{ Se elige la Alternativa 1 }

**Sustento:**
{ Swiper.js se integra perfectamente con React, ofreciendo una experiencia de usuario moderna y responsiva. Recharts, por su parte, es liviano, fácil de usar con React y cubre completamente las necesidades de visualización estadística del perfil. Ambas herramientas tienen buena documentación, soporte activo y se adaptan al enfoque modular del proyecto. }


## 03: Exploración musical

### Decisión 1:  
**Título:**
- Selección de tecnologías para el desarrollo, almacenamiento y despliegue del módulo de exploración musical

**Contexto:**  
El módulo 03 necesita tecnologías que permitan desarrollar una experiencia rápida, modular y escalable para la búsqueda y visualización de álbumes, artistas y usuarios. Además, requiere tecnologías que el equipo domine para no comprometer los tiempos de entrega y que se integren bien con el resto de la plataforma Singletone. Las decisiones tecnológicas deben considerar tanto el lenguaje de programación y framework, como la base de datos y la infraestructura de despliegue.

**Alternativas:**
1. **Lenguaje y Framework Backend:**
     - Alternativa 01: Node.js con NestJS (typescript, modularidad, soporte REST)
     - Alternativa 02: Python con FastAPI (rápido, ligero, pero menos modular y familiar para el equipo)
     - Alternativa 03: Java con Spring Boot (robusto, pero más pesado y con mayor curva de aprendizaje)

2. **Base de Datos:**
     - Alternativa 01: MongoDB (NoSQL orientado a documentos)
     - Alternativa 02: PostgreSQL (relacional, pero menos flexible para búsquedas variadas)
     - Alternativa 03: ElasticSearch (especializado en búsqueda, pero añade complejidad)
     
3. **Infraestructura:**
     - Alternativa 01: Contenedores Docker para facilitar el despliegue y escalabilidad
     - Alternativa 02: Despliegue directo en servidores (menos flexible y escalable)

**Criterios de elección:**
- **Simplicidad:** Se prioriza el uso de tecnologías fáciles de implementar y comprender para reducir la curva de aprendizaje.
- **Modularidad:** El sistema debe mantenerse desacoplado y organizado por responsabilidades, facilitando el mantenimiento y pruebas.
- **Eficiencia de ejecución:** Las búsquedas deben procesarse con rapidez para mantener la experiencia de usuario fluida.

**Decisión:**
Backend: Node.js con NestJS

Base de Datos: MongoDB

Infraestructura: Despliegue directo en servidores

**Sustento:**
La simplicidad de NestJS y su estructura modular permiten una arquitectura limpia y fácil de mantener. MongoDB aporta eficiencia en la ejecución de consultas flexibles, esenciales para el tipo de búsquedas que realiza este módulo. Finalmente, el despliegue directo en servidores responde a la infraestructura disponible y permite avanzar sin complicaciones adicionales.

## 04: Gestión de biblioteca

### Decisión 1:
**Título:**
- Tecnología para la manipulación de datos en el microservicio de Gestión de Biblioteca.

**Contexto:**
El microservicio de Gestión de Biblioteca necesitará interactuar con las bases de datos PostgreSQL (para la información del usuario) y MongoDB (para la biblioteca y las valoraciones). Es necesario elegir las librerías o los ORMs (Object-Relational Mappers) y ODMs (Object-Document Mappers) adecuados para facilitar esta interacción en Node.js.

**Alternativas:**
1. **Para PostgreSQL:**
    - `pg`: Librería de cliente PostgreSQL para Node.js, de bajo nivel y alto rendimiento.
    - `sequelize`: ORM popular para Node.js que soporta múltiples bases de datos SQL, incluyendo PostgreSQL. Ofrece abstracciones para la manipulación de datos y la definición de modelos.
    - `typeorm`: ORM para Node.js que soporta TypeScript y JavaScript, con un enfoque en características avanzadas y patrones de diseño.

2. **Para MongoDB:**
    - `mongodb`: Driver oficial de MongoDB para Node.js, de bajo nivel.
    - `mongoose`: ODM popular para Node.js que proporciona una forma elegante de interactuar con MongoDB, incluyendo la definición de esquemas y la validación de datos.
    - `mongoskin`: Otro ODM ligero para MongoDB.

**Criterios de elección:**
- **Facilidad de Uso:** La simplicidad de la API y la curva de aprendizaje.
- **Rendimiento:** La eficiencia en la interacción con la base de datos.
- **Características:** Las funcionalidades ofrecidas por la librería (ej. ORM, ODM, validación).
- **Comunidad y Soporte:** La disponibilidad de documentación y ayuda.

**Decisión:**
Utilizar `sequelize` para interactuar con PostgreSQL y `mongoose` para interactuar con MongoDB en el microservicio de Gestión de Biblioteca.

**Sustento:**
Tanto `sequelize` como `mongoose` son ORM/ODM populares y bien mantenidos en el ecosistema de Node.js. `Sequelize` facilitará la interacción con la base de datos relacional PostgreSQL, proporcionando abstracciones para la gestión de modelos y las consultas. `Mongoose` ofrecerá una forma intuitiva de trabajar con MongoDB, permitiendo definir esquemas para las colecciones y realizar operaciones de lectura y escritura de manera sencilla. El uso de ORM/ODM puede mejorar la productividad del equipo de desarrollo al abstraer las complejidades de las interacciones directas con la base de datos.

### Decisión 2:
**Título:**
- Tecnología para la comunicación en tiempo real (notificaciones de límite de valoraciones).

**Contexto:**
Se requiere una forma de comunicar notificaciones en tiempo real desde el backend (microservicio de Valoración Musical) al frontend (para mostrar el snack bar con los límites de valoración restantes).

**Alternativas:**
1. **WebSockets:**
    - Protocolo de comunicación bidireccional y persistente entre el navegador y el servidor.
    - Permite enviar mensajes en tiempo real sin necesidad de que el cliente realice solicitudes repetidas.
    - Ampliamente soportado por los navegadores modernos y los frameworks de backend (ej. Socket.IO, ws).

2. **Server-Sent Events (SSE):**
    - Tecnología que permite al servidor enviar eventos al navegador a través de una conexión HTTP persistente y unidireccional.
    - Más sencillo de implementar que WebSockets para la comunicación unidireccional del servidor al cliente.

3. **Polling o Long Polling:**
    - El cliente realiza solicitudes periódicas al servidor para verificar si hay nuevas notificaciones (polling) o mantiene una conexión abierta esperando una respuesta del servidor (long polling).
    - Menos eficiente que WebSockets o SSE en términos de latencia y uso de recursos.

**Criterios de elección:**
- **Tiempo Real:** La inmediatez con la que se deben mostrar las notificaciones.
- **Eficiencia:** El uso de recursos del servidor y del cliente.
- **Complejidad de Implementación:** El esfuerzo necesario para configurar y utilizar la tecnología.
- **Bidireccionalidad:** Si se requiere comunicación del cliente al servidor en tiempo real (aunque para las notificaciones de límite no es necesario).

**Decisión:**
WebSockets utilizando la librería Socket.IO.

**Sustento:**
WebSockets es la tecnología más adecuada para la comunicación en tiempo real bidireccional. Aunque para las notificaciones de límite de valoraciones solo se requiere comunicación del servidor al cliente, utilizar WebSockets proporciona una infraestructura flexible que podría utilizarse para otras funcionalidades en tiempo real en el futuro (si fueran necesarias). Socket.IO es una librería popular que simplifica la implementación de WebSockets, manejando automáticamente las diferentes tecnologías de transporte y proporcionando características adicionales como la reconexión automática.

## 05: Gestión de recomendaciones

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**



## 05: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

