# 4.2. Modelo de Coordinación

## 00: Decisiones generales

### Decisión 1:  
**Título:**
- Mecanismo de comunicación entre microservicios

**Contexto:**  
Dado que hemos optado por una arquitectura de microservicios, es crucial definir cómo se comunicarán los diferentes servicios entre sí para intercambiar información y coordinar acciones. Esta decisión impactará la latencia, la confiabilidad y la complejidad general del sistema.

**Alternativas:**
1. **Comunicación síncrona (RESTful API):**
     - Los microservicios se comunican directamente entre sí a través de solicitudes HTTP.
     - Simple de implementar para interacciones request/response.
     - Puede generar acoplamiento temporal entre servicios: el servicio A debe estar disponible para que el servicio B complete su operación.
     - La latencia puede aumentar si hay múltiples llamadas encadenadas.

2. **Comunicación asíncrona basada en eventos (Message Broker):**
     - Los microservicios se comunican a través de un intermediario (ej. RabbitMQ, Kafka) intercambiando mensajes o eventos.
     - Promueve el desacoplamiento temporal y espacial entre servicios.
     - Mejora la resiliencia: si un servicio está temporalmente inactivo, los mensajes se encolan y se procesan cuando vuelve a estar en línea.
     - Introduce la necesidad de una infraestructura de mensajería y puede ser más complejo de implementar para ciertos patrones de interacción (ej. request/response directo).
     - Facilita la escalabilidad y la adición de nuevos consumidores de eventos en el futuro.
     
**Criterios de elección:**
- **Desacoplamiento:** Minimizar las dependencias directas entre servicios.
- **Resiliencia:** La capacidad del sistema para seguir funcionando en caso de fallos temporales de algún servicio.
- **Escalabilidad:** La capacidad de manejar un gran volumen de interacciones entre servicios.
- **Latencia:** El tiempo de respuesta para las operaciones que involucran múltiples servicios.
- **Complejidad de Implementación:** El esfuerzo necesario para configurar y mantener el mecanismo de comunicación.

**Decisión:**
Comunicación síncrona (RESTful API).

**Sustento:**
Se opta por una comunicación síncrona mediante RESTful API debido a que varios casos de uso del sistema requieren una respuesta inmediata y directa entre servicios, como la consulta de datos en tiempo real (por ejemplo, la obtención del perfil de un usuario o la validación de credenciales). Esta modalidad facilita una implementación más sencilla y directa, lo que permite un desarrollo y una depuración más ágil en las etapas iniciales del sistema.

Además, dado el tamaño y la complejidad actual del sistema, los beneficios del bajo acoplamiento temporal que ofrece la comunicación asíncrona no justifican aún el costo adicional en infraestructura y complejidad operativa que implicaría incorporar y gestionar un sistema de mensajería. No obstante, se considera la posibilidad de integrar mecanismos asíncronos en el futuro, en puntos específicos donde la escalabilidad o la resiliencia sean más críticas.

## 01: Gestión de Usuarios

### Decisión 1:  
**Título:**
- Estrategia de coordinación entre servicios para el flujo de registro de usuarios

**Contexto:**  
Durante el registro, si el usuario selecciona la opción premium, se debe redirigir al sistema de pagos gestionado por el módulo de “Gestión de planes y monetización”. Este flujo requiere coordinación entre dos módulos que manejan responsabilidades distintas pero relacionadas.

**Alternativas:**
1. **Coordinación basada en orquestación mediante un servicio centralizado (UserService):**
     - La lógica de flujo se concentra en el UserService, que coordina llamadas entre el repositorio, autenticación, validación y gestor de planes.
     - El controlador solo actúa como intermediario entre la capa externa (cliente) y el servicio.
     - Alto control del flujo desde un único punto.
     - Fácil de mantener y escalar, ya que las reglas del negocio están centralizadas.
     - Facilita el manejo de errores, rollback y seguimiento de procesos.
     - Alineado con arquitecturas en capas tradicionales.

2. **Coordinación distribuida, con múltiples servicios colaborando entre sí:**
     - Cada servicio (registro, login, planes) toma decisiones de forma autónoma y se comunican entre sí de forma directa o mediante eventos.
     - Permite un diseño más flexible, especialmente útil en microservicios.
     - Mayor complejidad para coordinar y sincronizar los estados entre servicios.
     - Más difícil de rastrear el flujo completo de una operación.
     - Escalable en escenarios distribuidos, pero requiere mecanismos de comunicación (API Gateway, mensajería, etc.).
     - Ideal cuando los componentes están desplegados de manera independiente.
     
**Criterios de elección:**
- **Escalabilidad:** Capacidad de modificar y ampliar el sistema con mas componentes en el tiempo.
- **Mantenibilidad:** Capacidad de mantener el sistema actualizado en el tiempo.
- **Trazabilidad del flujo:** Capacidad para seguir el flujo de una operación a través de los distintos componentes del sistema.

**Decisión:**
Coordinación basada en orquestación mediante un servicio centralizado (UserService)

**Sustento:**
Dado que este es el primer módulo y la arquitectura aún está en una etapa temprana, una orquestación centralizada permite un desarrollo más rápido y fácil de depurar. Aunque más acoplada, facilita la implementación del flujo de registro premium sin necesidad de infraestructura adicional para eventos. En versiones futuras, se puede migrar a una arquitectura basada en eventos si el sistema lo requiere.


## 02: Visualización de perfil

### Decisión 1:  
**Título:**
- Coordinación entre secciones del perfil y otros módulos (usuarios, monetización y biblioteca)

**Contexto:**  
El perfil del usuario debe mostrar datos provenientes de distintas fuentes: información básica (módulo de usuarios), tipo de suscripción (módulo de monetización), y datos musicales (módulo de biblioteca). Se necesita definir cómo los distintos componentes del módulo de perfil se comunicarán entre ellos y con los módulos externos para obtener la información actualizada de manera eficiente y coherente.

**Alternativas:**
1. **Modelo basado en servicios coordinados mediante un controlador central de perfil:**
     - Un controlador central (ej. PerfilController) orquesta las peticiones a los servicios externos: usuario, monetización, biblioteca.
     - Cada sección del perfil (datos básicos, estadísticas, música) obtiene su información desde el controlador mediante props o inyección.
     - La coordinación es centralizada y predecible.
     - Favorece la encapsulación de lógica y facilita el testing.

2. **Modelo distribuido en el que cada componente hace sus propias llamadas a servicios externos:**
     - Cada sección del perfil se comunica directamente con los módulos correspondientes (servicio de usuarios, servicio de biblioteca, etc.).
     - Reducción de la lógica del controlador.
     - Mayor independencia entre componentes.
     - Más difícil de mantener coherencia y sincronización de datos si cambian en tiempo real.
     
**Criterios de elección:**
- **Escalabilidad:** Facilidad para extender el sistema (agregar nuevas secciones o funciones).
- **Consistencia:** Grado en que las distintas partes del sistema acceden a datos coherentes y sincronizados.
- **Reutilización:** Posibilidad de centralizar procesos comunes en un solo lugar para evitar duplicación.

**Decisión:**
Modelo basado en servicios coordinados mediante un controlador central de perfil

**Sustento:**
La centralización de la coordinación permite mantener el flujo de datos más controlado, evitando llamadas duplicadas o asincronías entre las distintas partes del perfil. Esto es especialmente relevante considerando que algunas vistas del perfil (como el estado de suscripción o el número de valoraciones disponibles) deben estar sincronizadas con otros módulos que podrían actualizarse en tiempo real. Además, al encapsular la lógica en un único controlador, se facilita su reutilización en futuras vistas relacionadas (por ejemplo, en un panel administrativo o en la vista pública del perfil).



## 03: Exploración musical

### Decisión 1:  
**Título:**
- Coordinación síncrona para interacción en tiempo real con módulos de Biblioteca y Perfiles.

**Contexto:**  
Este módulo necesita coordinarse con otros módulos para completar sus funcionalidades clave. Dado que estas coordinaciones impactan directamente en la experiencia del usuario y requieren de una respuesta inmediata, resulta importante definir un mecanismo de coordinación síncrona que garantice los tiempos de respuesta aceptables y consistencia en la interacción. 

**Alternativas:**
1. **Comunicación vía REST API:**
     - Comunicación vía REST API. Las interacciones se realizan mediante solicitudes HTTP directas a los servicios correspondientes, esperando la respuesta antes de continuar.

2. **Comunicación asíncrona vía eventos o colas de mensajes:**
     - Comunicación asíncrona vía eventos o colas de mensajes. Las interacciones se envían como eventos a un sistema de mensajería, sin esperar respuesta inmediata.
     
3. **Enfoque híbrido (REST para acciones críticas y eventos para procesos secundarios):**
     - Usar un enfoque híbrido, REST para las acciones críticas que requieren respuesta inmediata y eventos para procesos secundarios o de larga duración.

**Criterios de elección:**
- **Escalabilidad:** Si la carga crece, se deberán considerar opciones adicionales de reemplazo
- **Mantenibilidad:** Se debe buscar favorecer la separación de responsabilidades
- **Tiempo de Respuesta:** Se favorecerá la solución que ofrezca repuestas inmediatas y directas
- **Simplicidad:** Se priorizará la solución que sea más sencilla de implementar y mantener

**Decisión:**
Comunicación vía REST API.

**Sustento:**
Dado que las acciones del módulo 03 influyen directamente en la experiencia inmediata del usuario, como ver un álbum o agregarlo a su biblioteca, es necesario un mecanismo síncrono que permita mostrar resultados y confirmaciones de forma instantánea. REST API es una solución sencilla, estandarizada y soportada por el equipo actual, lo que facilita su adopción. Además, al mantener la comunicación stateless (sin conservar estado entre solicitudes), se garantiza que el sistema sea más fácil de escalar en el futuro. Si la plataforma crece significativamente, se evaluará la incorporación de mecanismos asíncronos para procesos secundarios, pero por ahora, REST API satisface los requisitos de interacción en tiempo real de manera eficiente y mantenible.

## 04: Gestión de biblioteca

### Decisión 1:  
**Título:**
- Coordinación para la eliminación de artistas y sus álbumes asociados.

**Contexto:**  
Cuando un usuario elimina un artista de su biblioteca, todos los álbumes asociados a ese artista también deben ser eliminados. Es necesario definir cómo se coordinará esta operación entre los diferentes componentes del módulo de Gestión de Biblioteca (o potencialmente con otros módulos si la información de la biblioteca está distribuida).

**Alternativas:**
1. **El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente:**
     - Al recibir una solicitud para eliminar un artista, el microservicio de Gestión de Biblioteca sería responsable de identificar y eliminar todos los álbumes asociados de la biblioteca del usuario.
     - Mantiene la lógica de eliminación en un solo lugar.
     - Podría volverse complejo si las relaciones entre artistas y álbumes se almacenan de forma distribuida.

2. **El microservicio de Gestión de Biblioteca emite un evento de "ArtistaEliminado" que es consumido por otros componentes para eliminar los álbumes asociados:**
     - Al eliminar un artista, el microservicio de Gestión de Biblioteca emitiría un evento que indique qué artista ha sido eliminado para un usuario específico.
     - Otros componentes (ej. el almacenamiento de la biblioteca de álbumes) escucharían este evento y realizarían la eliminación de los álbumes correspondientes.
     - Promueve el desacoplamiento y permite que diferentes partes del sistema reaccionen a la eliminación de un artista.
     - Requiere una infraestructura de mensajería.
     
**Criterios de elección:**
- **Consistencia de Datos:** Asegurar que tanto el artista como sus álbumes se eliminen de manera confiable.
- **Desacoplamiento:** Minimizar las dependencias entre los componentes responsables de la gestión de artistas y álbumes en la biblioteca.
- **Escalabilidad:** La capacidad de manejar un gran número de eliminaciones sin afectar el rendimiento.

**Decisión:**
El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente.

**Sustento:**
Dado que la relación entre artistas y sus álbumes dentro de la biblioteca de un usuario es un concepto relativamente local al módulo de Gestión de Biblioteca, manejar la eliminación en cascada directamente dentro de este microservicio simplifica la coordinación. No es necesario introducir la complejidad de la mensajería para esta operación específica, siempre y cuando la lógica de eliminación sea robusta y transaccional para asegurar la consistencia de los datos.

### Decisión 2:  
**Título:**
- Coordinación del proceso de valoración de álbumes y la activación de la opción "guardar".

**Contexto:**  
La opción de "guardar" la valoración de un álbum solo debe activarse cuando todas las canciones del álbum han sido valoradas. Es necesario definir cómo se coordinará el estado de las valoraciones de las canciones con la habilitación de la opción "guardar" en la interfaz de usuario.

**Alternativas:**
1. **El frontend consulta al backend (microservicio de Valoración Musical) para verificar si todas las canciones han sido valoradas antes de habilitar el botón "guardar":**
     - Cuando el usuario interactúa con la página de valoración de un álbum, el frontend realizaría una llamada al backend para determinar si todas las canciones tienen una valoración.
     - Simple de implementar inicialmente.
     - Puede generar múltiples llamadas al backend y aumentar la latencia.
     - La lógica de "álbum completo valorado" reside en el backend.

2. **El backend (microservicio de Valoración Musical) notifica al frontend (a través de un canal en tiempo real) cuando todas las canciones de un álbum han sido valoradas para que el frontend habilite el botón "guardar":**
     - El backend rastrearía el estado de valoración de cada canción de un álbum.
     - Cuando se detecta que todas las canciones han sido valoradas, el backend enviaría una notificación al frontend (ej. a través de WebSockets).
     - Reduce las llamadas innecesarias desde el frontend.
     - Requiere la implementación de un canal de comunicación en tiempo real.
     - La lógica de "álbum completo valorado" reside en el backend.
     
3. **El frontend mantiene el estado de las valoraciones y habilita el botón "guardar" localmente, y luego envía todas las valoraciones al backend al guardar:**
     - El frontend rastrearía si el usuario ha valorado todas las canciones mostradas.
     - El botón "guardar" se habilitaría localmente en el navegador cuando se cumplen las condiciones.
     - Al hacer clic en "guardar", todas las valoraciones se envían al backend.
     - Reduce la comunicación constante con el backend durante el proceso de valoración.
     - Requiere que el frontend tenga la lógica para determinar si un álbum está completamente valorado.

**Criterios de elección:**
- **Experiencia del Usuario:** La inmediatez con la que se habilita el botón "guardar".
- **Eficiencia:** Minimizar la comunicación innecesaria entre el frontend y el backend.
- **Separación de Responsabilidades:** Mantener la lógica de negocio en el backend.

**Decisión:**
El backend (microservicio de Valoración Musical) notifica al frontend (a través de un canal en tiempo real) cuando todas las canciones de un álbum han sido valoradas para que el frontend habilite el botón "guardar".

**Sustento:**
Este enfoque proporciona una buena experiencia de usuario al habilitar el botón "guardar" de forma casi inmediata una vez que se completa la valoración. Al mantener la lógica de "álbum completamente valorado" en el backend, se asegura la consistencia de las reglas del negocio. La implementación de un canal en tiempo real (como WebSockets) permite una comunicación eficiente y reactiva entre el backend y el frontend para esta funcionalidad específica.

## 05: Gestión de recomendaciones

### Decisión 1:  
**Título:**
- Coordinación de la recomendación de artistas basada en las valoraciones del usuario.

**Contexto:**  
El sistema de recomendaciones debe ofrecer sugerencias de nuevos artistas basadas en las valoraciones previas de un usuario. El desafío es cómo coordinar las valoraciones de los usuarios con las recomendaciones de nuevos artistas que podrían interesarles.

**Alternativas:**
1. **El microservicio de Recomendaciones consulta directamente las valoraciones del usuario en el backend:**
   - Cada vez que se genera una recomendación para un usuario, el microservicio de Recomendaciones consultaría las valoraciones previas del usuario para determinar qué artistas pueden ser de su interés.
   - Fácil de implementar inicialmente.
   - El sistema de recomendaciones se vuelve dependiente de las consultas a las valoraciones.
   - A medida que crecen las valoraciones, puede impactar el rendimiento de las consultas.

2. **El microservicio de Recomendaciones mantiene un perfil del usuario basado en sus valoraciones previas y realiza recomendaciones sin necesidad de consultar constantemente las valoraciones:**
   - Se podría generar un perfil de usuario en función de sus valoraciones pasadas, y las recomendaciones se generarían utilizando este perfil.
   - El sistema de recomendaciones sería más eficiente, ya que no depende de consultas constantes.
   - Requiere un mecanismo para actualizar el perfil del usuario cuando las valoraciones cambian.
   - Mantener perfiles personalizados puede ser costoso en términos de almacenamiento y gestión.

3. **El microservicio de Recomendaciones recibe eventos de valoraciones emitidos por el microservicio de Valoración Musical para actualizar el perfil del usuario y generar recomendaciones dinámicamente:**
   - El microservicio de Valoración Musical emitiría eventos que notificarían al microservicio de Recomendaciones sobre las nuevas valoraciones.
   - Basado en estos eventos, el microservicio de Recomendaciones actualizaría el perfil del usuario y generaría nuevas recomendaciones.
   - Promueve el desacoplamiento entre los microservicios y facilita la escalabilidad.
   - Requiere una infraestructura de mensajería (ej. Kafka, RabbitMQ).

**Criterios de elección:**
- **Desacoplamiento:** Minimizar las dependencias entre microservicios.
- **Eficiencia:** Minimizar el tiempo de respuesta de las recomendaciones.
- **Escalabilidad:** La capacidad de manejar un gran volumen de valoraciones y recomendaciones.
- **Mantenibilidad:** Facilitar la gestión y actualización de los perfiles de usuario.

**Decisión:**
El microservicio de Recomendaciones recibe eventos de valoraciones emitidos por el microservicio de Valoración Musical para actualizar el perfil del usuario y generar recomendaciones dinámicamente.

**Sustento:**
Este enfoque proporciona una solución eficiente y escalable, utilizando eventos para desacoplar los microservicios y permitir una actualización dinámica de las recomendaciones basadas en las valoraciones del usuario. La infraestructura de mensajería también facilita la extensión futura del sistema y la incorporación de otros consumidores de eventos.

---

### Decisión 2:  
**Título:**
- Coordinación de la generación de recomendaciones personalizadas.

**Contexto:**  
El microservicio de Recomendaciones debe generar recomendaciones personalizadas de acuerdo a las interacciones previas del usuario con artistas y álbumes. Es necesario definir cómo coordinar las recomendaciones personalizadas para mantener la relevancia sin generar recomendaciones excesivas.

**Alternativas:**
1. **El microservicio de Recomendaciones usa un algoritmo de filtrado colaborativo basado en las interacciones de usuarios similares:**
   - El sistema identifica usuarios con patrones de valoración similares y les recomienda los artistas que han valorado.
   - Facilita la personalización sin la necesidad de que cada usuario tenga un perfil explícito.
   - Dependiente de la base de datos de interacciones de usuarios.
   - Puede ser menos preciso si no se cuenta con un número suficiente de usuarios o valoraciones.

2. **El microservicio de Recomendaciones utiliza un perfil explícito del usuario basado en sus preferencias de género y artistas previos:**
   - El sistema crea un perfil de usuario con base en sus preferencias explícitas (género, artistas, álbumes).
   - Permite recomendaciones más dirigidas, pero depende de la precisión y actualización del perfil.
   - Puede generar recomendaciones muy centradas, limitando las opciones disponibles para el usuario.
   - Requiere un mantenimiento continuo de los perfiles.

3. **El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario:**
   - El sistema combina ambos métodos para crear recomendaciones que consideren tanto las interacciones previas como las preferencias explícitas del usuario.
   - Mejora la calidad de las recomendaciones al combinar lo mejor de ambos enfoques.
   - Requiere más recursos de procesamiento y almacenamiento.
   - Puede volverse complejo de mantener y actualizar.

**Criterios de elección:**
- **Precisión de las Recomendaciones:** Mejorar la calidad de las sugerencias basadas en las preferencias del usuario.
- **Flexibilidad:** Mantener las recomendaciones abiertas a futuros enfoques o combinaciones.
- **Escalabilidad:** Manejar un gran número de usuarios y recomendaciones sin afectar el rendimiento.
- **Mantenibilidad:** La facilidad de mantenimiento del sistema a medida que evoluciona.

**Decisión:**
El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario.

**Sustento:**
Un enfoque híbrido permite una personalización más precisa y flexible, asegurando que las recomendaciones sean relevantes tanto para los usuarios nuevos como para los más experimentados. Aunque requiere mayor complejidad en su implementación, mejora significativamente la calidad de las recomendaciones y mantiene el sistema preparado para futuras optimizaciones y escalabilidad.

---

### Decisión 3:  
**Título:**
- Coordinación de la actualización de las recomendaciones en tiempo real.

**Contexto:**  
Las recomendaciones deben actualizarse en tiempo real, especialmente después de que un usuario valore un álbum o un artista. Es necesario definir cómo coordinar la actualización inmediata de las recomendaciones sin afectar la experiencia del usuario.

**Alternativas:**
1. **El microservicio de Recomendaciones realiza la actualización de recomendaciones de forma síncrona con cada acción de valoración del usuario:**
   - Cuando un usuario valora un álbum o artista, el microservicio de Recomendaciones recalcularía las recomendaciones en tiempo real.
   - Asegura que las recomendaciones estén siempre actualizadas y relevantes.
   - Podría afectar el rendimiento si hay muchos usuarios valorando simultáneamente.

2. **El microservicio de Recomendaciones utiliza un mecanismo de actualización en segundo plano para recalcular las recomendaciones, notificando al frontend cuando las recomendaciones están listas:**
   - Cuando un usuario realiza una valoración, se envía una tarea en segundo plano para recalcular las recomendaciones, que estarán disponibles cuando el proceso termine.
   - Mejora el rendimiento y la experiencia del usuario, ya que no se bloquean las interacciones en el frontend.
   - Introduce la necesidad de un sistema de tareas en segundo plano y una gestión eficiente de las mismas.

3. **El microservicio de Recomendaciones emite eventos de actualización de recomendaciones que son consumidos por un servicio de cache para actualizar las recomendaciones en tiempo real sin recálculos completos:**
   - En lugar de recalcular las recomendaciones desde cero, el sistema actualiza el cache con las recomendaciones relevantes en función de los eventos de valoración.
   - Mejora el rendimiento al no necesitar un recálculo completo de las recomendaciones.
   - Requiere un sistema eficiente de gestión de cache y de eventos.

**Criterios de elección:**
- **Experiencia del Usuario:** Minimizar el tiempo de espera para nuevas recomendaciones.
- **Rendimiento:** Minimizar la carga en el sistema al actualizar las recomendaciones.
- **Escalabilidad:** La capacidad de manejar grandes volúmenes de usuarios y actualizaciones de recomendaciones.

**Decisión:**
El microservicio de Recomendaciones utiliza un mecanismo de actualización en segundo plano para recalcular las recomendaciones, notificando al frontend cuando las recomendaciones están listas.

**Sustento:**
El uso de actualizaciones en segundo plano mejora la experiencia del usuario al evitar bloqueos en la interfaz, mientras que permite una actualización eficiente de las recomendaciones. Este enfoque también optimiza el rendimiento al distribuir la carga de trabajo de manera controlada y escalable.


## 06: Gestión de planes

### Decisión 1:  
**Título:**
- { a }

**Contexto:**  
{ ingresar texto }

**Alternativas:**
1. **Alternativa 01:**
     - { ingresar texto }

2. **Alternativa 02:**
     - { ingresar texto }
     
**Criterios de elección:**
- **Escalabilidad:** { escribir }
- **Mantenibilidad:** { escribir }
- **{ otro criterio }:** { escribir }

**Decisión:**
{ escribi }

**Sustento:**

