# 0.7. Temas Individuales por Integrante (Informes)
- [Volver al √≠ndice](/0/0.md)

Sample content for section 0.7.

## Integrantes 01: Rodrigo De los R√≠os
***Arquitectura de Microservicios con Kubernetes***
### 1. Desarrollo conceptual
#### A. ¬øQu√© es la Arquitectura de Microservicios?  
La arquitectura de microservicios es un patr√≥n de dise√±o que estructura una aplicaci√≥n como una colecci√≥n de servicios peque√±os, independientes y d√©bilmente acoplados. Cada microservicio se ejecuta en su propo proceso y se comunica mediante APIs bien definidas, t√≠picamente HTTP/REST o messaging as√≠ncrono.  
![Arquitectura Monol√≠tica vs Arquitectura de Microservicios](./assets/mono_microservi.jpeg)  

#### B. Caracter√≠sticas principales  

- **Descentralizaci√≥n**: Cada servicio maneja su propia base de datos y l√≥gica de negocio.
- **Independencia**: Los servicios pueden ser desarrollados, desplegados y escalados independientemente.
- **Responsabilidad √∫nica**: Cada microservicio tiene una funci√≥n espec√≠fica y bien definida.
- **Tolerancia a fallos**: El fallo de un servicio no compromete toda la aplicaci√≥n.
- **Tecnolog√≠a agn√≥stica**: Cada servicio puede usar diferentes tecnolog√≠as y lenguajes.

#### C. Importancia y utilidad
***Ventajas:***
- **Escalabilidad granular**: Escalar solo los componentes que lo necesiten.
- **Desarrollo paralelo**: Equipos independientes trabajando en diferentes servicios.
- **Despliegue independiente**: Actualizaciones sin afectar el sistema completo.
- **Resiliencia**: Aislamiento de fallos entre servicios.
- **Flexibilidad tecnol√≥gica**: Libertad de elegir la mejor tecnolog√≠a para cada servicio.

***Limitaciones:***
- **Complejidad operacional**: Gesti√≥n de m√∫ltiples servicios y comunicaci√≥n.
- **Latencia de red**: Comunicaci√≥n entre servicios introduce overhead.
- **Consistencia de datos**: Transacciones distribuidas son complejas.
- **Monitoreo**: Necesidad de observabilidad avanzada.
- **Testing**: Pruebas de integraci√≥n m√°s complejas.

#### D. Por qu√© usar Microservicios  
Los microservicios resultan especialmente √∫tiles cuando una aplicaci√≥n cuenta con m√∫ltiples dominios de negocio claramente definidos, requiere que sus componentes escalen de forma independiente, involucra a diferentes equipos trabajando en distintas partes del sistema, necesita flexibilidad para adoptar nuevas tecnolog√≠as o demanda una alta disponibilidad y resiliencia.

#### E. Casos pr√°cticos
- **Netflix**: Miles de microservicios para streaming, recomendaciones, facturaci√≥n.
- **Amazon**: Servicios independientes para cat√°logo, pagos, env√≠os, reviews.
- **Spotify**: Microservicios para m√∫sica, playlists, usuarios, recomendaciones.
- **Uber**: Servicios separados para usuarios, conductores, pagos, mapas.  

![Casos pr√°cticos](./assets/casos_practicos.jpg)  

### 2. Contexto de Soluci√≥n
#### A. Situaci√≥n Actual: Singletone como Monolito

Actualmente, Singletone est√° dise√±ada como una aplicaci√≥n monol√≠tica con 6 m√≥dulos principales:

- **Gesti√≥n de usuarios** ‚Äî‚Äî Registro, autenticaci√≥n, perfiles.
- **Visualizaci√≥n de perfil** ‚Äî- Dashboard personal y estad√≠sticas.
- **Exploraci√≥n musical** -‚Äî B√∫squeda y descubrimiento.
- **Gesti√≥n de biblioteca** ‚Äî- Administraci√≥n de m√∫sica personal.
- **Gesti√≥n de recomendaciones** ‚Äî- Sistema de ML para sugerencias.
- **Gesti√≥n de planes** -‚Äî Suscripciones y pagos.

#### B. Problemas Identificados
**Escalabilidad Limitada**
El m√≥dulo de recomendaciones, al ser intensivo en machine learning, demanda m√°s recursos que otros componentes del sistema; adem√°s, la b√∫squeda musical puede experimentar picos de tr√°fico de forma independiente, y las funciones premium presentan patrones de uso distintos, lo que refuerza la necesidad de una arquitectura flexible y escalable.

**Complejidad de Desarrollo**
Cuando equipos distintos trabajan sobre la misma base de c√≥digo, pueden surgir conflictos y cuellos de botella que dificultan el desarrollo √°gil. Adem√°s, los despliegues se vuelven m√°s arriesgados, ya que un cambio puede afectar a toda la aplicaci√≥n. Esta estructura monol√≠tica tambi√©n limita la posibilidad de experimentar con nuevas tecnolog√≠as, al estar todo estrechamente acoplado.

**Limitaciones T√©cnicas**
Contar con una base de datos central compartida por todos los m√≥dulos puede generar cuellos de botella y dificultar la independencia entre componentes. Adem√°s, utilizar una √∫nica tecnolog√≠a ‚Äîprobablemente en un enfoque monol√≠tico basado en un solo framework‚Äî limita la flexibilidad del sistema. Este tipo de arquitectura tambi√©n suele presentar restricciones a la hora de escalar horizontalmente, afectando su capacidad de respuesta ante una alta demanda.

### C. Benficios esperados
**Para el negocio**
- Tiempo de desarrollo reducido: Equipos paralelos trabajando independientemente.
- Experimentaci√≥n segura: Cambios en recomendaciones sin afectar otros servicios.
- Escalabilidad econ√≥mica: Escalar solo lo que necesita m√°s recursos.

**Para los usuarios**
- Mejor rendimiento: Servicios optimizados individualmente.
- Mayor disponibilidad: Fallos aislados no tumban toda la plataforma.
- Nuevas funcionalidades: Desarrollo m√°s √°gil de features.

**Para el equipo t√©cnico**
- Flexibilidad tecnol√≥gica: Python para ML, Node.js para APIs, Go para performance.
- Despliegues independientes: Actualizaciones sin downtime.
- Monitoreo granular: Observabilidad por servicio.

### 3. ¬øQu√© es Kubernetes y c√≥mo funciona?
Kubernetes (K8s) es una plataforma de orquestaci√≥n de contenedores open-source que automatiza el despliegue, escalado y gesti√≥n de aplicaciones containerizadas. Originalmente desarrollado por Google, se basa en m√°s de 15 a√±os de experiencia ejecutando cargas de trabajo de producci√≥n a escala.
![Arquitectura com√∫n de Kubernetes](./assets/cluster_pods.jpeg)

#### A. Componentes principales de Kubernetes
**Controle Plane (Panel de Control)**:
- API Server: Punto de entrada para todas las operaciones del cluster.
- etcd: Base de datos distribuida que almacena la configuraci√≥n del cluster.
- Scheduler: Decide en qu√© nodos ejecutar los pods.
- Controller Manager: Ejecuta los controladores que regulan el estado del cluster.

**Worker nods**:
- kubelet: Agente que se ejecuta en cada nodo y gestiona los pods.
- kube-proxy: Componente de red que mantiene las reglas de red.
- Container Runtime: Motor que ejecuta los contenedores (Docker, containerd).

![k8s arquitecura](./assets/k8s_architecture.png)

#### B. Conceptos fundamentales
**Pods:**
- Unidad m√°s peque√±a desplegable en Kubernetes.
- Puede contener uno o m√°s contenedores que comparten red y almacenamiento.
- Los contenedores en un pod siempre se ejecutan en el mismo nodo.

**Services:**
- Abstracci√≥n que define un conjunto l√≥gico de pods.
- Proporciona descubrimiento de servicios y balanceado de carga.
- Tipos: ClusterIP, NodePort, LoadBalancer, ExternalName.

**Deployments:**
- Gestiona el despliegue y actualizaci√≥n de aplicaciones.
- Asegura que el n√∫mero deseado de r√©plicas est√© ejecut√°ndose.
- Facilita rolling updates y rollbacks.

**ConfigMaps y Secrets:**
- ConfigMaps: Almacenan datos de configuraci√≥n no confidenciales.
- Secrets: Almacenan informaci√≥n sensible como passwords y tokens.

**Ingress:**
- Gestiona el acceso externo a los servicios del cluster.
- Proporciona balanceado de carga, terminaci√≥n SSL y virtual hosting.

#### C. C√≥mo Kubernetes Orquesta los Microservicios
**1. Service discovery**
```
# Los servicios se registran autom√°ticamente en DNS interno
user-service.default.svc.cluster.local
music-service.default.svc.cluster.local
``` 

**2. Load balancing**
- Kubernetes distribuye autom√°ticamente el tr√°fico entre r√©plicas.
- Detecta pods no saludables y los excluye del balanceado.

**3. Auto-scaling**
- Horizontal Pod Autoscaler (HPA): Escala pods basado en CPU/memoria.
- Vertical Pod Autoscaler (VPA): Ajusta recursos de pods.
- Cluster Autoscaler: A√±ade/remueve nodos seg√∫n demanda.

**4. Health checks**
- Liveness Probes: Determina si un pod est√° vivo
- Readiness Probes: Determina si un pod est√° listo para recibir tr√°fico
- Startup Probes: Para aplicaciones con tiempos de inicio lentos

### 4. Consideraciones t√©cnicas
A continuaci√≥n, se detalla las consideraciones que debe tener el programador antes de comenzar la implementaci√≥n de Kubernetes. Este proceso incluir√° tanto la descarga de Kubernetes y Docker, como verificar que el proyecto creado se encuentre corriendo.

### A. Requisitos previos
**Instalar Docker Desktop**  

Para ello nos dirigimos a la siguiente URL: [Docker Desktop](https://www.docker.com/products/docker-desktop/) y descargamos la versi√≥n compatible con nuestro sistema operativo (En caso uses macOS con chip M, descarga la opci√≥n "Apple Silicon". De lo contrario, ve por "Intel Chip").  

![Docker Desktop download](./assets/docker_desktop_download.png)

Con ello listo, abrimos la aplicaci√≥n para habilitar Kubernetes a trav√©s de la ruta "Settings (√≠cono) -> Kubernetes -> Enable Kubernetes":  
![Habilitar Kubernetes](./assets/kubernetes_enable.png)
Y luego de clickear "Apply & Restart", tomar√° un tiempo en instalar todos los paquetes y dependencias de internet (necesitar√°n conexi√≥n obligatoriamente). Aunque descuiden, este proceso solo tarda la primera vez. Al final de todo les saldr√° el mensaje confirmaci√≥n.  
![Kubernetes habilitado](./assets/kubernetes_ready.png)

**Inslar kubectl (sino viene con Docker Desktop)**  
```
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
```
Abran un terminal, pueden hacerlo desde vscode o la terminal b√°sica de su sistema operativo. En mi caso, estar√© usando Warp que tiene autocompletado y sugerencias con AI:  
![Descarga de Kubectl](./assets/kubectl_install.png)

**Verificiar instalaci√≥n**  
El √∫ltimo paso, verificar la correcta instalaci√≥n de todos los componentes.  
![Verificacion k8s](./assets/verificacion_k8s.png)

#### B. Configuraci√≥n inicial
```
# Crear namespace para el proyecto
kubectl create namespace { el nombre de tu proyecto }

# Verificamos que Kubernetes est√© corriendo
kubectl get nodes
```
Y este deber√≠a ser el resultado, importante tener el Docker Desktop abierto:  
![Namespace y Nodos](./assets/configuracion_inicial.png)

### 5. Demo t√©cnica
Con la finalidad de demostrar la funcionlidad de Kubernetes, estaremos aplicando su uso al software "Singletone". Un software de valoraci√≥n musical en el que cada usuario almacena valoraciones de √°lbumes musicales, siendo su principal diferenciador el que es un gestor de contenido m√°s que una red social. En singletone, solo importa "tu" opini√≥n.

Lo √∫nico a considerar es que por el alcance de la actividad, estaremos reduciendo las funcionlidades a una sola, as√≠ como la configuraci√≥n completa de ciertas herramientas. V√©ase el frontend y backend que tendr√°n archivos m√°s sencillos, contrario a cuando se hace un aplicativo masivo.

#### A. Estructura de Carpetas
Al momenta de manejar contenedores, es de suma importancia mantener una estructura de carpetas impecable. Pues, estaremos usando rutas al momento de establecer las configuraciones. Recomendamos esta para la demo:  
![Estructura de carpetas](./assets/estructura_carpetas.png)

#### B. Backend
Como se ve en la carpeta, debemos de configurar 3 archivos importantes.  
**Dockerfile**  
Este nos ayudar√° a dockerizar el microservicio a futuro.  
![dockerfile_frontend](./assets/backend_dockerfile.png)

**Package.json**  
Encargado de gestionar dependencias y scripts.  
![package_frontend](./assets/backend_package.png)

**Server.js**
Aqu√≠ configuraremos las rutas y servicios APIs que ofrecer√° nuestro backend.
```
const express = require('express');
const { Pool } = require('pg');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3001;

// Configuraci√≥n de PostgreSQL
const pool = new Pool({
    host: process.env.DB_HOST || 'postgres-service',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'singletone',
    user: process.env.DB_USER || 'admin',
    password: process.env.DB_PASSWORD || 'password123'
});

app.use(cors());
app.use(express.json());

// Inicializar base de datos
async function initDB() {
    try {
        await pool.query(`
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            nickname VARCHAR(50) UNIQUE NOT NULL,
            plan VARCHAR(20) DEFAULT 'gratuito',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        `);
        console.log('Tabla users creada');
    } catch (err) {
        console.error('Error creando tabla:', err);
    }
}

// Rutas API
app.get('/health', (req, res) => {
    res.json({ status: 'OK', service: 'singletone-backend' });
});

app.get('/api/users', async (req, res) => {
    try {
        const result = await pool.query('SELECT * FROM users ORDER BY created_at DESC');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching users:', err);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});

app.post('/api/users', async (req, res) => {
    const { name, email, nickname } = req.body;
    
    try {
        const result = await pool.query(
        'INSERT INTO users (name, email, nickname) VALUES ($1, $2, $3) RETURNING *',
        [name, email, nickname]
        );
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error creating user:', err);
        if (err.code === '23505') {
        res.status(400).json({ error: 'Email o nickname ya existe' });
        } else {
        res.status(500).json({ error: 'Error interno del servidor' });
        }
    }
});

setTimeout(() => {
    initDB().then(() => {
        app.listen(PORT, '0.0.0.0', () => {
        console.log(`üöÄ Backend corriendo en puerto ${PORT}`);
        });
    });
}, 5000);
```

#### C. Frontend
**Dockerfile**
Mismo procedimiento.  
![dockerfile_frontend](./assets/frontend_dockerfile.png)

**Pacakge.json**
Mismo procedimiento.  
![pacakge_frontend](./assets/frontend_package.png)

**Index.astro**  
Aqu√≠ configuramos lo que ver√° el usuario. Hemos adjunto la imagen del body; sin embargo, en el repositorio de la demo puedes ver el c√≥digo completo.
![index_frontend](./assets/frontend_index.png)

#### D. Configuraci√≥n de Kubernetes
**namespace.yml**  
Este archivo es necesario para: crear el namespace singletone, donde se desplegar√°n todos los recursos del proyecto, permitiendo su organizaci√≥n y aislamiento dentro del cl√∫ster de Kubernetes.
```
apiVersion: v1
kind: Namespace
metadata:
  name: singletone
```

**postgres-config.yaml**  
Este archivo es necesario para: onfigurar y desplegar una base de datos PostgreSQL, incluyendo:
- Un ConfigMap con credenciales y nombre de la base de datos.
- Un Deployment que levanta un contenedor de PostgreSQL con persistencia ef√≠mera (emptyDir).
- Un Service que expone PostgreSQL dentro del namespace para que otros servicios lo puedan usar.

```
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
  namespace: singletone
data:
  POSTGRES_DB: singletone
  POSTGRES_USER: admin
  POSTGRES_PASSWORD: password123
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: singletone
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        envFrom:
        - configMapRef:
            name: postgres-config
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-data
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: singletone
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
```

**backend-deployment.yaml**  
Este archivo es necesario para: desplegar el backend de la aplicaci√≥n, incluyendo:  
- Un Deployment que levanta 2 r√©plicas del contenedor singletone-backend.
- Variables de entorno para conectarse a la base de datos PostgreSQL.
- Un Service tipo LoadBalancer para exponer el backend dentro del cl√∫ster y al exterior si es necesario.
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: singletone
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: singletone-backend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3001
        env:
        - name: DB_HOST
          value: "postgres-service"
        - name: DB_NAME
          value: "singletone"
        - name: DB_USER
          value: "admin"
        - name: DB_PASSWORD
          value: "password123"
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: singletone
spec:
  selector:
    app: backend
  ports:
  - port: 3001
    targetPort: 3001
  type: LoadBalancer
```

**frontend-deployment.yaml**  
Este archivo es necesario para: desplegar el frontend de la aplicaci√≥n, incluyendo:
- Un Deployment que levanta una r√©plica del contenedor singletone-frontend.
- Una variable de entorno que apunta al backend.
- Un Service tipo LoadBalancer para exponer la interfaz de usuario al exterior del cl√∫ster.

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: singletone
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: singletone-frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 4321
        env:
        - name: PUBLIC_API_URL
          value: "http://backend-service:3001"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: singletone
spec:
  selector:
    app: frontend
  ports:
  - port: 3000
    targetPort: 4321
  type: LoadBalancer
```

#### E. Deployment
Debemos de configurar un script que levante todos los servicios cuando los solicitemos, el mismo es: "build-and-deploy.sh" y contiene el siguiente c√≥digo:
```
#!/bin/bash

echo "Construyendo im√°genes Docker..."

# Build backend
cd backend
docker build -t singletone-backend:latest .
cd ..

# Build frontend
cd frontend
docker build -t singletone-frontend:latest .
cd ..

echo "Desplegando en Kubernetes..."

# Aplicar configuraciones
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/postgres-config.yaml
kubectl apply -f k8s/backend-deployment.yaml
kubectl apply -f k8s/frontend-deployment.yaml

echo "Esperando que los pods est√©n listos..."
kubectl wait --for=condition=ready pod -l app=postgres -n singletone --timeout=120s
kubectl wait --for=condition=ready pod -l app=backend -n singletone --timeout=120s
kubectl wait --for=condition=ready pod -l app=frontend -n singletone --timeout=120s

echo "Despliegue completado!"
echo "Accede a la aplicaci√≥n en: http://localhost:3000"

# Mostrar estado
kubectl get pods -n singletone
kubectl get services -n singletone
```

#### F. Proceso de levantamiento
Primero debemos asegurar que docker desktop est√© abierto:  
![docker abierto](./assets/docker_abierto.png)

Luego, levantamos los servicios.  
![levantando servicios](./assets/levantando_servicios.png)

Una vez se confirme que todo est√© correcto, podremos probar el peque√±o aplicativo que hemos realizado.  
![frontend funcional](./assets/frontend_funcional.png)

Como vemos, funciona correctamente y permite el registro de usuarios.  
![frontend final](./assets/frontend_final.png)

### 6. Link del repositorio
Todo lo desarrollado previamente se encuentra en el siguiente repositorio p√∫blico:
[enlace a github](https://github.com/RoudiOlding/arqui251_individual_01)

## Integrante 02: Adri√°n Duarte
**Tema:** NoSQL - Bases de Datos de Clave / Valor

### 1. Desarrollo conceptual
Se conoce como base de datos de clave-valor, o NoSQL, a la base de datos no relacional que utiliza un m√©todo simple de clave-valor para almacenar los datos, como un conjunto de pares clave-valor en los que una clave sirve como un identificador √∫nico. Aunque est√° dise√±ado para modelos de datos espec√≠ficos, este tipo de base de datos es altamente divisible y permite escalado horizontal a niveles que otros tipos de bases de datos no pueden alcanzar. Finalmente, las bases de datos NoSQL son f√°ciles de desarrollar, por su funcionalidad y el rendimiento a escala.
Tanto las claves como los valores pueden ser cualquier cosa, desde objetos simples hasta objetos compuestos complejos.

#### 1.1 Ventajas
Las aplicaciones procesan un gran volumen de datos de fuentes dispares, como las redes sociales, los sensores inteligentes y las bases de datos de terceros. Todos estos datos dispares no encajan perfectamente en el modelo relacional. La aplicaci√≥n de estructuras tabulares puede provocar redundancia, duplicaci√≥n de datos y problemas de rendimiento a escala. El NoSQL evita esos problemas gracias a su:

- Flexibilidad: Ofrecen esquemas flexibles que permiten un desarrollo m√°s r√°pido y m√°s iterativo, ideal para datos semiestructurados y no estructurados
- Escalabilidad: Est√°n dise√±adas para escalar horizontalmente usando cl√∫steres distribuidos de hardware, en lugar de escalar a√±adiendo servidores caros y s√≥lidos
- Alto rendimiento: Est√°n optimizadas para modelos de datos y patrones de acceso espec√≠ficos, permitiendo un mayor rendimiento que si intentara lograr una funcionalidad similar con bases de datos relacionales
- Altamente funcional: Proporcionan API altamente funcionales y tipos de datos que est√°n dise√±ados espec√≠ficamente para cada uno de sus respectivos modelos de datos

#### 1.2 Casos de uso
Se puede usar NoSQL para crear una amplia variedad de aplicaciones m√≥viles, de Internet of Things (Internet de las cosas (IoT)), de juegos y web de alto rendimiento que proporcionan excelentes experiencias de usuario a escala. Por ejemplo:

- Administraci√≥n de datos en tiempo en tiempo real: Puede ofrecer recomendaciones en tiempo real, personalizaci√≥n y experiencias de usuario mejoradas con bases de datos NoSQL. Por ejemplo, Disney+ ofrece su amplia biblioteca de contenido digital a m√°s de 150 millones de suscriptores mediante la tecnolog√≠a de base de datos NoSQL. Puede escalar y ofrecer funciones populares, como Seguir viendo, Mi lista y Recomendaciones personalizadas con Amazon DynamoDB
- Seguridad en la nube: Puede usar bases de datos de grafos para descubrir r√°pidamente relaciones complejas en sus datos. Por ejemplo, Wiz reimagin√≥ la seguridad en la nube como un gr√°fico con Amazon Neptune. Wiz ayuda a sus clientes a mejorar su postura de seguridad al identificar y corregir r√°pidamente los riesgos m√°s cr√≠ticos. Utilizan un modelo gr√°fico almacenado en Amazon Neptune para descubrir la combinaci√≥n t√≥xica de factores de riesgo que representan riesgos cr√≠ticos. Los motores de riesgo de Wiz recorren el gr√°fico y, en cuesti√≥n de segundos, entrelazan una serie de factores de riesgo interconectados en un gr√°fico de seguridad
- Aplicaciones de alta disponibilidad: Las bases de datos NoSQL distribuidas son excelentes para crear aplicaciones de alta disponibilidad y baja latencia para mensajer√≠a, redes sociales, uso compartido de archivos y m√°s. Por ejemplo, Snapchat tiene m√°s de 290 millones de usuarios que env√≠an miles de millones de im√°genes y mensajes de video a diario. Utiliza sistemas de bases de datos NoSQL para reducir la latencia media del env√≠o de mensajes en un 20 %

#### 1.3 Funcionamiento
Las bases de datos NoSQL utilizan una variedad de modelos de datos para acceder y administrar datos. Estos tipos de bases de datos est√°n optimizados espec√≠ficamente para aplicaciones que requieren modelos de datos flexibles, grandes vol√∫menes de datos y baja latencia, lo que se logra mediante la flexibilizaci√≥n de algunas de las restricciones de coherencia de datos en bases de datos relacionales. Existen diferencias en la implementaci√≥n seg√∫n el modelo de datos. Sin embargo, muchas bases de datos NoSQL utilizan Javascript Object Notation (JSON), un formato de intercambio de datos abierto que representa los datos como una colecci√≥n de pares nombre-valor.

Fuentes: https://aws.amazon.com/es/nosql/, https://aws.amazon.com/es/nosql/key-value/

### 2. Consideraciones t√©cnicas
Programa: Amazon DynamoDB
![alt text](assets/AmazonDBgratis.png)

Pasos para el plan gratuito:
1. Entrar a: https://signin.aws.amazon.com/signup?request_type=register
(Si no tienes cuenta)
a. Ingresar tu correo e inventar un nombre
b. Ingresar el c√≥digo de verificaci√≥n enviado a tu correo
c. Crear una contrase√±a para tu cuenta
d. Rellenar todos los campos (nombre completo, organizaci√≥n, tel√©fono, aceptar t√©rminos y condiciones, etc)
e. Ingresar los datos de tu tarjeta
d. Confirmar tu n√∫mero de tel√©fono y pasar el CAPTCHA
e. Elegir plan de soporte (gratuito)
f. Presionar el bot√≥n "Ir a la consola de administraci√≥n de AWS"
![alt text](assets/Amazoncuenta.png)
(Si tienes cuenta)
a. Presionar el bot√≥n "Sign in to an existing AWS acount"
b. Ingresar sesi√≥n por IAM o por correo
(Se seguir√° la ruta del correo)
c. Presionar el bot√≥n "Sign in using root user email"
d. Ingresar usuario y contrase√±a
e. Ingresar c√≥digo de verificaci√≥n enviado al correo
2. Llegar a esta pantalla
![alt text](assets/dynamoLogin.png)
3. Presionar las 3 l√≠neas de la esquina superior izquierda
4. Presionar el texto "Todos los servicios"
5. Presionar el texto Base de datos->"DynamoDB" (tambi√©n lo puedes buscar en el buscador)
![alt text](assets/dynamo.png)
6. Presionar "Crear tabla"
7. Escribir el nombre de la tabla y el nombre de la clave de partici√≥n
8. Presionar "Crear tabla"
9. Presionar el nombre de tu tabla
10. Presionar "Acciones->Crear elemento"
11. Introducir los datos de tu elemento, mediante el bot√≥n "Agregar nuevo atributo". Por ejemplo, los siguientes:
![alt text](assets/dynamoej1.png)
12. Presionar "Crear elemento"
13. Crear un 2do elemento, pero con distintos atributos
![alt text](assets/ej2.png)
Como se puede apreciar, DynamoDB creo el 2do elemento sin ning√∫n error. A diferencia de SQL, no necesita modificar la tabla para agregar o renombrar las columnas
![alt text](assets/tada.png)


### 3. Demo (C√≥digo)
Deben presentar un escenario de aplicaci√≥n y realizar una implementaci√≥n simple utilizando el tema desarrollado. El c√≥digo debe estar publicado en el repositorio Github del grupo.

## Integrantes 03: Alejandro Ch√°vez

# Observabilidad y monitoreo de aplicaciones
En el desarrollo de software moderno, especialmente en entornos distribuidos y basados en microservicios, garantizar la estabilidad, el rendimiento y la r√°pida detecci√≥n de problemas es crucial. Aqu√≠ es donde entran en juego la observabilidad y el monitoreo, dos conceptos interrelacionados pero distintos que permiten a los equipos de desarrollo y operaciones mantener sistemas confiables y eficientes.

## Monitoreo
El monitoreo se refiere al proceso de recopilar, analizar y visualizar datos sobre el comportamiento de un sistema para detectar anomal√≠as, evaluar el rendimiento y generar alertas cuando ocurren problemas conocidos.

### Objetivos del monitoreo
- Deteci√≥n de fallos: Identificar errores a tiempo real, como por ejemplo ca√≠das del servidor o degradaci√≥n del rendimiento.
- Alertas proactivas: Identificar problemas y notificarlos antes de que los usuarios puedan verse afectados.
- Tendencia hist√≥rica: Analizar las m√©tricas a lo largo del tiempo para facilitar la toma de decisiones
- Cumplimiento de acuerdos a nivel de servicio: Asegurar que el sistema cumple con proveer el nivel de servicio acordado.

### Tipos de monitoreo
- De infraestructura: Supervisa los recursos del sistema (CPU, memoria, disco, red, servidores).
- De aplicaciones: Supervisa el rendimiento de las aplicaciones, evaluando que estas funcionen con regularidad, buscando errores o problemas de latencia.
- De usuarios: Monitorea la experiencia del usuario final que usa el sistema.
- De logs: Recolecta y analiza registros de eventos, esto incluye cosas como solicitudes y errores junto con su informaci√≥n detallada.

## Observabilidad
A diferencia del monitoreo, el cual se enfoca en problemas conocidos, la observabilidad se enfoca en descubrir nuevos problemas de los cuales no se tiene registro previo, mediante el an√°lisis de datos entrantes y salientes del sistema. Facilita la resoluci√≥n de problemas, mejora el rendimiento y la confiabilidad del sistema, y permite una optimizaci√≥n proactiva.

La observabilidad cuenta con tres pilares fundamentales:
- M√©tricas: Datos num√©ricos que cuantifican aspectos clave de un sistema, tales como el rendimiento, uso de recursos, latencia y tasa de errores. El uso de m√©tricas permite monitorear el estado de un sistema en el tiempo e identificar patrones y tendencias.
- Logs/Registros: Mensajes generados el sistema que describen eventos que toman lugar en este. Estos registros ayudan a comprender qu√© est√° sucediendo dentro del sistema y bajo que contexto para as√≠ identificar errores y depurar problemas.
- Trazas: Registros de eventos relacionados entre diferentes componentes de un mismo sistema, mostrando el flujo del evento a trav√©s de m√∫ltiples servicios del sistema. Las trazas permiten rastrear la ra√≠z de un problema y entender c√≥mo las diferentes partes de un sistema interact√∫an entre s√≠ durante este evento. Especialmente √∫til en una arquitectura de microservicios.

## Diferencias entre monitoreo y observabilidad
|  | **Monitoreo** | **Observabilidad** |
|------------------|------------------|------------------|
Enfoque Principal | Recopilar datos para identificar anomal√≠as en el sistema | Investigar la causa de las anomal√≠as en el sistema
Sistemas Involucrados | Mayormente sistemas independientes | Sistemas m√∫ltiples y dispares
Nivel de trazabilidad | Limitado a un mismo sistema | Disponible cuando las se√±ales se transmiten entre sistemas dispares
Resultados | Que error sucedi√≥ y cuando | Por qu√© sucedi√≥ el error y como

## Sentry
Sentry es una plataforma del tipo SaaS enfocada en la observabilidad y monitoreo, especializada en detecci√≥n de errores en tiempo real de aplicaciones, ayudando a los desarrolladores a identificar la causa, frecuencia e impacto de estos. Sentry adem√°s permite monitorear el rendimiento de las aplicaciones. Sentry es compatible con una amplia gama de lenguajes de programaci√≥n, por lo que es ideal para cualquier tipo de proyecto, adem√°s es utilizado por grandes empresas como Disney y Microsoft.

### Ejemplo de flujo de trabajo con Sentry
| **Paso** | **Acci√≥n** | **Resultado** |
|------------------|------------------|------------------|
1 | El usuario hace clic en un bot√≥n | Se lanza un error
2 | Sentry captura el error | El error aparece en el dashboard
3 | El equipo recibe una alerta	| Se prioriza la soluci√≥n
4 | Se implementa una soluci√≥n | Sentry monitorea si el error reaparece

## Consideraciones t√©cnicas
### Requisitos b√°sicos:
- Tener una cuenta en sentry.io
- SDK compatible con el lenguaje usado en tu proyecto
- DNS de tu proyecto en Sentry

### Instalaci√≥n
Una vez que creas tu proyecto en la p√°gina de Sentry, se proporciona documentaci√≥n simple y espec√≠fica sobre como instalar e iniciar el servicio de Sentry en tu aplicaci√≥n, dependiendo de que lenguaje de programaci√≥n se este utilizando.

### Bloqueadores de anuncios y rastreadores
Cuando desplegamos una aplicaci√≥n web, algunos usuarios podr√≠an hacer uso de extensiones o navegadores especiales para bloquear anuncios y otros rastreadores, en algunos casos estos pueden dificultar el monitoreo por parte de Sentry. Para asegurarse de que la aplicaci√≥n este enviando la informaci√≥n a Sentry con normalidad, se puede utilizar la consola del navegdor y en la pesta√±a "Network" buscar las solicitudes a Sentry.

## Demo de detecci√≥n de errores con Sentry
https://github.com/AleGCC/arqi-demo-sentry

## Integrantes 04: Angel Alcal√°

***Monorepo con NX***

## ¬øQu√© es un Monorepo?

Un **monorepo** (abreviatura de *monolithic repository*) es una estrategia para organizar el c√≥digo fuente de m√∫ltiples proyectos o servicios dentro de un √∫nico repositorio. A diferencia de los *multirepos* (donde cada servicio tiene su propio repositorio), en un monorepo todos los servicios, librer√≠as, herramientas y configuraciones coexisten bajo una misma estructura de carpetas.

![Arquitectura Monorepo](./assets/monorepo_esquema.png)  

### Caracter√≠sticas principales

- **C√≥digo centralizado**: Todo el c√≥digo est√° en un solo repositorio.
- **Organizaci√≥n modular**: Cada servicio o paquete se organiza en su propio directorio.
- **Gesti√≥n compartida de dependencias**: Es posible utilizar herramientas para manejar versiones y dependencias de forma centralizada.
- **Facilidad de refactorizaci√≥n**: Permite hacer cambios coordinados entre m√∫ltiples servicios sin depender de m√∫ltiples repositorios.

### Ventajas

- ‚úÖ **Coordinaci√≥n entre equipos**: Los equipos pueden ver los cambios de otros servicios y colaborar mucho m√°s f√°cilmente.
- ‚úÖ **Reutilizaci√≥n de c√≥digo**: Las librer√≠as compartidas son m√°s accesibles.
- ‚úÖ **Versionado unificado**: Todos los servicios pueden mantenerse sincronizados con un mismo historial de versiones.
- ‚úÖ **Automatizaci√≥n coherente**: Pipelines, linters, tests y builds pueden ser definidos globalmente.

### Desventajas

- ‚ö†Ô∏è **Escalabilidad del repositorio**: A medida que crece, las herramientas de Git pueden volverse m√°s lentas si no se usan correctamente.
- ‚ö†Ô∏è **Dependencias impl√≠citas**: Es f√°cil que los servicios comiencen a depender unos de otros innecesariamente.
- ‚ö†Ô∏è **Complejidad en los flujos de CI/CD**: Requiere una configuraci√≥n cuidadosa para no disparar builds innecesarios en cada cambio.

### Ejemplos de herramientas compatibles

- **Turborepo** (JavaScript/TypeScript)
- **Nx** (JavaScript/TypeScript)
- **Bazel** (general, muy usado por Google)
- **Lerna** (monorepos con m√∫ltiples paquetes npm)
- **Rush** (de Microsoft para proyectos grandes)

### Casos de uso comunes

- Grandes empresas con m√∫ltiples equipos trabajando en servicios relacionados.
- Proyectos donde se desea mantener coherencia entre APIs, librer√≠as y utilidades.
- Aplicaciones modulares con backend, frontend y librer√≠as compartidas.

### Estructura t√≠pica de un monorepo

/repo-root
‚îú‚îÄ‚îÄ /packages
‚îÇ ‚îú‚îÄ‚îÄ service-auth/
‚îÇ ‚îú‚îÄ‚îÄ service-recommendations/
‚îÇ ‚îú‚îÄ‚îÄ frontend-app/
‚îÇ ‚îî‚îÄ‚îÄ shared-utils/
‚îú‚îÄ‚îÄ /scripts
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ turbo.json / nx.json / lerna.json


> Un monorepo no es adecuado para todos los casos, pero bien gestionado puede ser una soluci√≥n poderosa para equipos con m√∫ltiples servicios que necesitan mantenerse coordinados.

## ¬øQu√© es Nx y c√≥mo funciona?

**Nx** es un framework extensible para construir monorepos a gran escala. Creado por antiguos ingenieros de Angular en Google, Nx facilita la gesti√≥n de m√∫ltiples aplicaciones y bibliotecas dentro de un mismo repositorio. Automatiza tareas de desarrollo, integra herramientas modernas, y proporciona un enfoque estructurado para proyectos modulares con equipos colaborativos.

> Nx no solo organiza el c√≥digo, tambi√©n mejora la productividad mediante an√°lisis de dependencias, ejecuci√≥n incremental, y herramientas de testing, build y deploy optimizadas.

---

### A. Componentes principales de Nx

#### Workspace (Espacio de trabajo)

- Estructura base que contiene todas las aplicaciones y librer√≠as del monorepo.
- Configurado mediante archivos como `nx.json`, `workspace.json` o `project.json`.

#### Apps y Libs

- **Apps**: Aplicaciones ejecutables (frontend, backend, mobile, etc.).
- **Libs**: Librer√≠as reutilizables para l√≥gica compartida, interfaces, utilidades, etc.

#### Nx CLI

- Interfaz de l√≠nea de comandos para generar, testear, compilar, lintar y servir proyectos.
- Ejemplo: `nx serve my-app`, `nx build my-lib`, `nx test my-lib`.

#### Graph (Dependency Graph)

- Visualiza las dependencias entre apps y libs.
- Usa `nx graph` para abrir un grafo interactivo en el navegador.

#### Computation Caching

- Nx guarda resultados de tareas (build, test, lint) para evitar repetirlas si nada ha cambiado.
- El cache puede ser local o distribuido (ej. Nx Cloud).

---

### B. Conceptos fundamentales

#### Project Configuration

- Cada aplicaci√≥n o librer√≠a tiene su configuraci√≥n espec√≠fica.
- Usa esquemas JSON para definir targets como `build`, `test`, `lint`, etc.

#### Target Executor

- Define c√≥mo se ejecuta una tarea (`webpack`, `vite`, `jest`, `eslint`, etc.).
- Personalizable para adaptarse a cualquier stack (Node.js, React, Angular, NestJS, etc.).

#### Affected Projects

- Usa `nx affected` para ejecutar tareas solo en proyectos que han cambiado desde la √∫ltima commit.
- Ejemplo: `nx affected:test` corre tests solo en librer√≠as afectadas por los √∫ltimos cambios.

#### Plugins

- Nx ofrece plugins oficiales y de la comunidad para tecnolog√≠as como React, Angular, NestJS, Next.js, Express, Storybook, Jest, Cypress, Tailwind, entre otros.
- Permiten generar c√≥digo y configurar autom√°ticamente herramientas espec√≠ficas.

---

### C. C√≥mo Nx potencia los Monorepos

#### 1. Desarrollo modular

- Cada equipo puede trabajar en su propia app o lib de forma aislada.
- Promueve la reutilizaci√≥n y mantenimiento de c√≥digo compartido.

#### 2. Ejecuci√≥n optimizada

- Nx solo ejecuta las tareas necesarias, gracias al an√°lisis de dependencias y su cache inteligente.
- Acelera pipelines de CI/CD y mejora la experiencia local.

#### 3. Escalabilidad t√©cnica y organizacional

- Ideal para equipos grandes trabajando en m√∫ltiples dominios.
- Permite estrategias de ownership por carpeta, dominio o tecnolog√≠a.

#### 4. Integraci√≥n con herramientas modernas

- Soporte nativo para Jest, Cypress, ESLint, Prettier, Webpack, Vite, Storybook, etc.
- Compatible con cualquier stack moderno (TypeScript, Node.js, React, Angular, etc.).

---

### D. Ejemplo de estructura de un workspace con Nx


/my-workspace
‚îú‚îÄ‚îÄ apps/
‚îÇ ‚îú‚îÄ‚îÄ music-app/ # Frontend principal
‚îÇ ‚îî‚îÄ‚îÄ api-gateway/ # Backend en NestJS
‚îú‚îÄ‚îÄ libs/
‚îÇ ‚îú‚îÄ‚îÄ auth/ # Librer√≠a de autenticaci√≥n
‚îÇ ‚îú‚îÄ‚îÄ recommendations/ # L√≥gica de recomendaciones
‚îÇ ‚îî‚îÄ‚îÄ ui/ # Componentes compartidos (React)
‚îú‚îÄ‚îÄ nx.json
‚îú‚îÄ‚îÄ workspace.json
‚îî‚îÄ‚îÄ tsconfig.base.json


> Nx permite escalar desde un solo proyecto hasta cientos de apps y librer√≠as con control, rendimiento y consistencia.

## Consideraciones T√©cnicas: Monorepo con Nx

A continuaci√≥n, se detallan las consideraciones que debe tener un desarrollador antes de comenzar la implementaci√≥n de un monorepo con **Nx**. Este proceso incluye la instalaci√≥n de Nx CLI, la inicializaci√≥n del workspace, la configuraci√≥n de proyectos, y la verificaci√≥n de que todo funcione correctamente.

---

### A. Requisitos previos

#### Instalar Node.js

Es necesario contar con Node.js (recomendado: versi√≥n LTS 18 o superior).

Puedes descargarlo desde la p√°gina oficial: [https://nodejs.org/](https://nodejs.org/)


node -v     # Verifica versi√≥n

#### Instalar Nx CLI

Una vez que tienes Node.js, puedes instalar Nx de forma global o usar npx:


npm install -g nx
o usando npx directamente sin instalar globalmente
npx create-nx-workspace@latest


### Instalar Git

Nx trabaja mejor dentro de un repositorio Git. Aseg√∫rate de tenerlo instalado y configurado:

git --version




## Integrantes 05: Erick Valderrama
## Integrantes 05: Erick Valderrama

# Desarrollo seguro de aplicaciones: Un ejemplo de almacenamiento seguro de sesi√≥n en una aplicaci√≥n m√≥vil

## 1. Desarrollo conceptual

### 1.1. ¬øQu√© es el desarrollo seguro de aplicaciones?

El desarrollo seguro de aplicaciones consiste en integrar pr√°cticas, principios y herramientas de seguridad durante todo el ciclo de vida del software, desde la fase de dise√±o hasta la implementaci√≥n y mantenimiento. Este enfoque busca proteger la confidencialidad, integridad y disponibilidad de los datos, y evitar que las aplicaciones se conviertan en vectores de ataque.

Dado que se trata de un conjunto de pr√°cticas, es posible adoptar tanto herramientas auxiliares que apoyen en este objetivo, como tambi√©n t√©cnicas de desarrollo que fortalezcan la seguridad del proyecto. Cualquier medida adicional que permita prevenir vulnerabilidades contribuye significativamente.

A diferencia de estrategias tradicionales, donde la seguridad se abordaba al final del proceso, hoy se considera un principio arquitect√≥nico fundamental que debe guiar las decisiones t√©cnicas desde el inicio del proyecto.

### 1.2. Principales amenazas en el desarrollo de aplicaciones

El panorama actual de ciberseguridad revela m√∫ltiples vectores de ataque que afectan tanto a aplicaciones web como m√≥viles. Seg√∫n OWASP (2023), algunas de las amenazas m√°s comunes incluyen:

- **Almacenamiento inseguro de datos sensibles**
- **Falta de cifrado en la transmisi√≥n de datos**
- **Exposici√≥n de secretos o claves API en el c√≥digo fuente**
- **Errores de validaci√≥n de entradas del usuario**
- **Sesiones mal gestionadas o f√°cilmente predecibles**

Estas vulnerabilidades pueden derivar en la filtraci√≥n de informaci√≥n personal, suplantaci√≥n de identidad o ejecuci√≥n de acciones no autorizadas en nombre del usuario. Aunque muchas veces estas amenazas pasan desapercibidas, los peque√±os descuidos en el desarrollo son justamente los que generan mayores oportunidades para los atacantes.

### 1.3. Principios clave del desarrollo seguro

El desarrollo seguro debe regirse por principios s√≥lidos para mitigar los riesgos mencionados. A continuaci√≥n, se listan los m√°s relevantes en relaci√≥n con la demo que se presentar√° m√°s adelante:

- **Minimizar la superficie de ataque**: eliminar funciones innecesarias o expuestas.
- **Cifrar datos sensibles tanto en reposo como en tr√°nsito**.
- **Separar los secretos del c√≥digo fuente** mediante variables de entorno o configuraciones externas.
- **Validar y sanear toda entrada del usuario** para prevenir inyecciones o manipulaciones.
- **Gestionar sesiones y tokens de forma robusta**, evitando almacenamientos inseguros o predecibles.

### 1.4. Almacenamiento seguro de sesi√≥n: ejemplo aplicado

Uno de los componentes clave en la seguridad de aplicaciones m√≥viles es el almacenamiento de informaci√≥n de sesi√≥n, como los tokens de acceso. Guardar este tipo de informaci√≥n en texto plano (por ejemplo, usando `SharedPreferences` sin cifrado) representa un riesgo cr√≠tico.

En plataformas como Android e iOS existen soluciones nativas como **Keystore** (sistema seguro de claves en Android) y **Keychain** (gestor seguro de credenciales en iOS), que permiten almacenar informaci√≥n cifrada y accesible √∫nicamente por la aplicaci√≥n. Para apps multiplataforma como las desarrolladas en Flutter, se puede utilizar la librer√≠a `flutter_secure_storage`, que abstrae estas soluciones ofreciendo un almacenamiento cifrado de forma unificada.

> ‚úÖ Ejemplo seguro: guardar un token de sesi√≥n con `flutter_secure_storage`  
> ‚ùå Ejemplo inseguro: guardar un token en `SharedPreferences` sin cifrar

Este tipo de enfoque permite proteger la persistencia de la sesi√≥n del usuario sin comprometer la seguridad de sus datos personales.

Cabe destacar que las soluciones nativas por s√≠ solas no bastan para garantizar la seguridad de un proyecto; es necesario complementarlas con otras medidas y pr√°cticas dentro del desarrollo.

### 1.5. Limitaciones del almacenamiento seguro

Aunque el almacenamiento seguro es una herramienta poderosa, tiene ciertas limitaciones que deben tenerse en cuenta:

- No evita ataques si el dispositivo est√° comprometido (por ejemplo, si tiene **root** en Android o **jailbreak** en iOS, lo que otorga control total al usuario o atacante sobre el sistema).
- No protege si se **hardcodean** secretos (es decir, si se incluyen claves o tokens directamente en el c√≥digo fuente).
- No reemplaza una arquitectura segura de extremo a extremo (es decir, que tambi√©n considere el backend, la red y la autenticaci√≥n del servidor).

Por eso, se recomienda utilizarlo dentro de una estrategia m√°s amplia de seguridad que incluya el cifrado de datos en tr√°nsito (HTTPS), autenticaci√≥n segura y control de acceso desde el backend.

### 1.6. Casos de uso comunes

- Aplicaciones financieras o de banca m√≥vil
- Apps de mensajer√≠a o salud
- Plataformas educativas con sesi√≥n persistente
- Aplicaciones de autenticaci√≥n de doble factor (2FA)
- Cualquier app que maneje datos sensibles de usuario

## 2. Contexto de soluci√≥n

### 2.1. Escenario propuesto

El presente ejemplo se enmarca dentro de una aplicaci√≥n m√≥vil educativa desarrollada con Flutter. Esta app permite a los usuarios iniciar sesi√≥n y conservar su estado de autenticaci√≥n de forma persistente y segura.

Para ello, se aborda una problem√°tica com√∫n: **¬øC√≥mo almacenar de manera segura el token de sesi√≥n del usuario en un dispositivo m√≥vil?**

En vez de usar mecanismos inseguros como `SharedPreferences` (Android) o `NSUserDefaults` (iOS), se implementa la librer√≠a `flutter_secure_storage`, que permite cifrar los datos almacenados, aprovechando los mecanismos nativos de seguridad de cada plataforma (Keystore en Android y Keychain en iOS).

El flujo de seguridad que se implementar√° es el siguiente:

1. El usuario inicia sesi√≥n correctamente.
2. El backend retorna un token (simulado).
3. El token se almacena de forma cifrada en el dispositivo usando `flutter_secure_storage`.
4. En sesiones futuras, se verifica autom√°ticamente si el token sigue presente y v√°lido, permitiendo el ingreso sin tener que volver a autenticarse.

Este ejemplo busca demostrar una **t√©cnica sencilla y efectiva para proteger sesiones de usuario**, compatible con los principios del desarrollo seguro.

### 2.2. Objetivo de la soluci√≥n

- Aplicar el principio de "almacenamiento seguro de informaci√≥n sensible".
- Mostrar una implementaci√≥n multiplataforma con **Flutter** y la librer√≠a **flutter_secure_storage**.
- Concientizar sobre los riesgos del uso de almacenamiento no cifrado en aplicaciones m√≥viles.
- Sentar las bases para implementar sesiones persistentes seguras y escalables.

### 2.3. Requisitos para la implementaci√≥n

#### Tecnolog√≠as utilizadas

- **Flutter SDK** (3.19 o superior)
- **Dart**
- **Visual Studio Code** o **Android Studio**
- **Dispositivo f√≠sico o emulador Android/iOS**

#### Librer√≠as necesarias

- [`flutter_secure_storage`](https://pub.dev/packages/flutter_secure_storage): Almacenamiento seguro
- [`flutter/material.dart`](https://api.flutter.dev/): Interfaz de usuario

#### Instalaci√≥n del paquete


flutter pub add flutter_secure_storage


## 3. Demo

### 3.1. Escenario propuesto

Para demostrar el concepto de almacenamiento seguro en una aplicaci√≥n m√≥vil, se desarroll√≥ una app simple en **Flutter** que simula un flujo muy b√°sico de login. Al autenticarse, se guarda un token de sesi√≥n en el dispositivo de forma segura utilizando la librer√≠a `flutter_secure_storage`. Este token se persiste incluso si la aplicaci√≥n se reinicia, pero se elimina al cerrar sesi√≥n.

Esto permite representar un flujo de sesi√≥n seguro, evitando almacenar datos sensibles en texto plano o en espacios vulnerables como `SharedPreferences`.

---

### 3.2. Estructura general

El proyecto est√° compuesto por los siguientes archivos clave:

/lib

‚îî‚îÄ‚îÄ main.dart ‚Üí Pantalla principal con login simulado y bot√≥n de logout
/test

‚îî‚îÄ‚îÄ widget_test.dart ‚Üí Test b√°sico de funcionalidad

/pubspec.yaml ‚Üí Declaraci√≥n de dependencias



---

### 3.3. C√≥digo fuente (main.dart)

```dart
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  final secureStorage = const FlutterSecureStorage();

  MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Secure Session App',
      theme: ThemeData(primarySwatch: Colors.blue),
      home: FutureBuilder<String?>(
        future: secureStorage.read(key: 'token'),
        builder: (context, snapshot) {
          final token = snapshot.data;
          if (token != null) {
            return HomePage(secureStorage: secureStorage);
          } else {
            return LoginPage(secureStorage: secureStorage);
          }
        },
      ),
    );
  }
}

class LoginPage extends StatelessWidget {
  final FlutterSecureStorage secureStorage;

  const LoginPage({super.key, required this.secureStorage});

  void _login(BuildContext context) async {
    await secureStorage.write(key: 'token', value: 'abc123');
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => HomePage(secureStorage: secureStorage)),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => _login(context),
          child: const Text('Iniciar sesi√≥n'),
        ),
      ),
    );
  }
}

class HomePage extends StatelessWidget {
  final FlutterSecureStorage secureStorage;

  const HomePage({super.key, required this.secureStorage});

  void _logout(BuildContext context) async {
    await secureStorage.delete(key: 'token');
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => LoginPage(secureStorage: secureStorage)),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Inicio')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => _logout(context),
          child: const Text('Cerrar sesi√≥n'),
        ),
      ),
    );
  }
}

```
---
### 3.4. Test b√°sico de funcionalidad

Se incluye un test b√°sico generado por defecto en Flutter que verifica si el contador de la aplicaci√≥n incrementa correctamente al presionar el bot√≥n con √≠cono "+". Esto permite comprobar que el entorno de pruebas est√° configurado correctamente y que la estructura general del widget principal responde a interacciones.

#### C√≥digo del test (ubicado en `/test/widget_test.dart`):

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:secure_login_app/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Construye la app y lanza el primer frame
    await tester.pumpWidget(MyApp());

    // Verifica que el contador empieza en 0
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Toca el √≠cono de "+" y actualiza la UI
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verifica que el contador ahora muestra 1
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```

#### Nota t√©cnica:

Este test fue adaptado para la versi√≥n flutter_secure_storage: ^9.2.4. Para evitar errores de compatibilidad en el entorno de pruebas, se elimin√≥ la palabra clave const en la l√≠nea:

await tester.pumpWidget(MyApp()); // sin `const`

Esto se debe a que el constructor MyApp() ya no puede ser constante si su contenido depende de librer√≠as o estructuras no constantes, como es el caso de las que acceden a almacenamiento seguro o a contextos externos en tiempo de ejecuci√≥n.

### C√≥mo ejecutar el emulador en Android Studio

1. Abrir **Android Studio**.
2. Ir a la pesta√±a **Device Manager** (en la barra lateral derecha).
3. Localizar el emulador configurado, por ejemplo: `Pixel 5 API 33 (Tiramisu)`.
4. Haz clic en el √≠cono de **play ‚ñ∂Ô∏è** para iniciarlo.
5. Una vez iniciado el emulador, ejecuta el proyecto desde VS Code o Android Studio con:

```bash
flutter run
```

Tambien se recomienda ejecutar:
```bash
flutter doctor
```

antes de ejecutar todo y adicionalmente se recomienda ejecutar 2 veces flutter run para resolver la instalaci√≥n de dependencias.




### 3.5. Repositorio y ejecuci√≥n

El enlace al c√≥digo completo es:
([Repositorio](https://github.com/DmitriVurb/Informe_Individual_ArquiSoft1051.git))

Para correr el proyecto localmente:

```

git clone https://github.com/tu-grupo/secure-login-app

cd secure-login-app

flutter pub get

flutter run

```

Asimismo se recomienda poner en "Modo desarrollador" el Sistema




## üìö Fuentes

- OWASP Foundation. (2023). [OWASP Mobile Top 10](https://owasp.org/www-project-mobile-top-10/)
- Flutter. (s.f.). [flutter_secure_storage](https://pub.dev/packages/flutter_secure_storage)
- Android Developers. (s.f.). [Keystore system](https://developer.android.com/training/articles/keystore)
- Apple Developer. (s.f.). [Keychain Services](https://developer.apple.com/documentation/security/keychain_services)