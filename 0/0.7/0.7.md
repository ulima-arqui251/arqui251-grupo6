# 0.7. Temas Individuales por Integrante (Informes)
- [Volver al √≠ndice](/0/0.md)

Sample content for section 0.7.

## Integrantes 01: Rodrigo De los R√≠os
***Arquitectura de Microservicios con Kubernetes***
### 1. Desarrollo conceptual
#### A. ¬øQu√© es la Arquitectura de Microservicios?  
La arquitectura de microservicios es un patr√≥n de dise√±o que estructura una aplicaci√≥n como una colecci√≥n de servicios peque√±os, independientes y d√©bilmente acoplados. Cada microservicio se ejecuta en su propo proceso y se comunica mediante APIs bien definidas, t√≠picamente HTTP/REST o messaging as√≠ncrono.  
![Arquitectura Monol√≠tica vs Arquitectura de Microservicios](./assets/mono_microservi.jpeg)  

#### B. Caracter√≠sticas principales  

- **Descentralizaci√≥n**: Cada servicio maneja su propia base de datos y l√≥gica de negocio.
- **Independencia**: Los servicios pueden ser desarrollados, desplegados y escalados independientemente.
- **Responsabilidad √∫nica**: Cada microservicio tiene una funci√≥n espec√≠fica y bien definida.
- **Tolerancia a fallos**: El fallo de un servicio no compromete toda la aplicaci√≥n.
- **Tecnolog√≠a agn√≥stica**: Cada servicio puede usar diferentes tecnolog√≠as y lenguajes.

#### C. Importancia y utilidad
***Ventajas:***
- **Escalabilidad granular**: Escalar solo los componentes que lo necesiten.
- **Desarrollo paralelo**: Equipos independientes trabajando en diferentes servicios.
- **Despliegue independiente**: Actualizaciones sin afectar el sistema completo.
- **Resiliencia**: Aislamiento de fallos entre servicios.
- **Flexibilidad tecnol√≥gica**: Libertad de elegir la mejor tecnolog√≠a para cada servicio.

***Limitaciones:***
- **Complejidad operacional**: Gesti√≥n de m√∫ltiples servicios y comunicaci√≥n.
- **Latencia de red**: Comunicaci√≥n entre servicios introduce overhead.
- **Consistencia de datos**: Transacciones distribuidas son complejas.
- **Monitoreo**: Necesidad de observabilidad avanzada.
- **Testing**: Pruebas de integraci√≥n m√°s complejas.

#### D. Por qu√© usar Microservicios  
Los microservicios resultan especialmente √∫tiles cuando una aplicaci√≥n cuenta con m√∫ltiples dominios de negocio claramente definidos, requiere que sus componentes escalen de forma independiente, involucra a diferentes equipos trabajando en distintas partes del sistema, necesita flexibilidad para adoptar nuevas tecnolog√≠as o demanda una alta disponibilidad y resiliencia.

#### E. Casos pr√°cticos
- **Netflix**: Miles de microservicios para streaming, recomendaciones, facturaci√≥n.
- **Amazon**: Servicios independientes para cat√°logo, pagos, env√≠os, reviews.
- **Spotify**: Microservicios para m√∫sica, playlists, usuarios, recomendaciones.
- **Uber**: Servicios separados para usuarios, conductores, pagos, mapas.  

![Casos pr√°cticos](./assets/casos_practicos.jpg)  

### 2. Contexto de Soluci√≥n
#### A. Situaci√≥n Actual: Singletone como Monolito

Actualmente, Singletone est√° dise√±ada como una aplicaci√≥n monol√≠tica con 6 m√≥dulos principales:

- **Gesti√≥n de usuarios** ‚Äî‚Äî Registro, autenticaci√≥n, perfiles.
- **Visualizaci√≥n de perfil** ‚Äî- Dashboard personal y estad√≠sticas.
- **Exploraci√≥n musical** -‚Äî B√∫squeda y descubrimiento.
- **Gesti√≥n de biblioteca** ‚Äî- Administraci√≥n de m√∫sica personal.
- **Gesti√≥n de recomendaciones** ‚Äî- Sistema de ML para sugerencias.
- **Gesti√≥n de planes** -‚Äî Suscripciones y pagos.

#### B. Problemas Identificados
**Escalabilidad Limitada**
El m√≥dulo de recomendaciones, al ser intensivo en machine learning, demanda m√°s recursos que otros componentes del sistema; adem√°s, la b√∫squeda musical puede experimentar picos de tr√°fico de forma independiente, y las funciones premium presentan patrones de uso distintos, lo que refuerza la necesidad de una arquitectura flexible y escalable.

**Complejidad de Desarrollo**
Cuando equipos distintos trabajan sobre la misma base de c√≥digo, pueden surgir conflictos y cuellos de botella que dificultan el desarrollo √°gil. Adem√°s, los despliegues se vuelven m√°s arriesgados, ya que un cambio puede afectar a toda la aplicaci√≥n. Esta estructura monol√≠tica tambi√©n limita la posibilidad de experimentar con nuevas tecnolog√≠as, al estar todo estrechamente acoplado.

**Limitaciones T√©cnicas**
Contar con una base de datos central compartida por todos los m√≥dulos puede generar cuellos de botella y dificultar la independencia entre componentes. Adem√°s, utilizar una √∫nica tecnolog√≠a ‚Äîprobablemente en un enfoque monol√≠tico basado en un solo framework‚Äî limita la flexibilidad del sistema. Este tipo de arquitectura tambi√©n suele presentar restricciones a la hora de escalar horizontalmente, afectando su capacidad de respuesta ante una alta demanda.

### C. Benficios esperados
**Para el negocio**
- Tiempo de desarrollo reducido: Equipos paralelos trabajando independientemente.
- Experimentaci√≥n segura: Cambios en recomendaciones sin afectar otros servicios.
- Escalabilidad econ√≥mica: Escalar solo lo que necesita m√°s recursos.

**Para los usuarios**
- Mejor rendimiento: Servicios optimizados individualmente.
- Mayor disponibilidad: Fallos aislados no tumban toda la plataforma.
- Nuevas funcionalidades: Desarrollo m√°s √°gil de features.

**Para el equipo t√©cnico**
- Flexibilidad tecnol√≥gica: Python para ML, Node.js para APIs, Go para performance.
- Despliegues independientes: Actualizaciones sin downtime.
- Monitoreo granular: Observabilidad por servicio.

### 3. ¬øQu√© es Kubernetes y c√≥mo funciona?
Kubernetes (K8s) es una plataforma de orquestaci√≥n de contenedores open-source que automatiza el despliegue, escalado y gesti√≥n de aplicaciones containerizadas. Originalmente desarrollado por Google, se basa en m√°s de 15 a√±os de experiencia ejecutando cargas de trabajo de producci√≥n a escala.
![Arquitectura com√∫n de Kubernetes](./assets/cluster_pods.jpeg)

#### A. Componentes principales de Kubernetes
**Controle Plane (Panel de Control)**:
- API Server: Punto de entrada para todas las operaciones del cluster.
- etcd: Base de datos distribuida que almacena la configuraci√≥n del cluster.
- Scheduler: Decide en qu√© nodos ejecutar los pods.
- Controller Manager: Ejecuta los controladores que regulan el estado del cluster.

**Worker nods**:
- kubelet: Agente que se ejecuta en cada nodo y gestiona los pods.
- kube-proxy: Componente de red que mantiene las reglas de red.
- Container Runtime: Motor que ejecuta los contenedores (Docker, containerd).

![k8s arquitecura](./assets/k8s_architecture.png)

#### B. Conceptos fundamentales
**Pods:**
- Unidad m√°s peque√±a desplegable en Kubernetes.
- Puede contener uno o m√°s contenedores que comparten red y almacenamiento.
- Los contenedores en un pod siempre se ejecutan en el mismo nodo.

**Services:**
- Abstracci√≥n que define un conjunto l√≥gico de pods.
- Proporciona descubrimiento de servicios y balanceado de carga.
- Tipos: ClusterIP, NodePort, LoadBalancer, ExternalName.

**Deployments:**
- Gestiona el despliegue y actualizaci√≥n de aplicaciones.
- Asegura que el n√∫mero deseado de r√©plicas est√© ejecut√°ndose.
- Facilita rolling updates y rollbacks.

**ConfigMaps y Secrets:**
- ConfigMaps: Almacenan datos de configuraci√≥n no confidenciales.
- Secrets: Almacenan informaci√≥n sensible como passwords y tokens.

**Ingress:**
- Gestiona el acceso externo a los servicios del cluster.
- Proporciona balanceado de carga, terminaci√≥n SSL y virtual hosting.

#### C. C√≥mo Kubernetes Orquesta los Microservicios
**1. Service discovery**
```
# Los servicios se registran autom√°ticamente en DNS interno
user-service.default.svc.cluster.local
music-service.default.svc.cluster.local
``` 

**2. Load balancing**
- Kubernetes distribuye autom√°ticamente el tr√°fico entre r√©plicas.
- Detecta pods no saludables y los excluye del balanceado.

**3. Auto-scaling**
- Horizontal Pod Autoscaler (HPA): Escala pods basado en CPU/memoria.
- Vertical Pod Autoscaler (VPA): Ajusta recursos de pods.
- Cluster Autoscaler: A√±ade/remueve nodos seg√∫n demanda.

**4. Health checks**
- Liveness Probes: Determina si un pod est√° vivo
- Readiness Probes: Determina si un pod est√° listo para recibir tr√°fico
- Startup Probes: Para aplicaciones con tiempos de inicio lentos

### 4. Consideraciones t√©cnicas
A continuaci√≥n, se detalla las consideraciones que debe tener el programador antes de comenzar la implementaci√≥n de Kubernetes. Este proceso incluir√° tanto la descarga de Kubernetes y Docker, como verificar que el proyecto creado se encuentre corriendo.

### A. Requisitos previos
**Instalar Docker Desktop**  

Para ello nos dirigimos a la siguiente URL: [Docker Desktop](https://www.docker.com/products/docker-desktop/) y descargamos la versi√≥n compatible con nuestro sistema operativo (En caso uses macOS con chip M, descarga la opci√≥n "Apple Silicon". De lo contrario, ve por "Intel Chip").  

![Docker Desktop download](./assets/docker_desktop_download.png)

Con ello listo, abrimos la aplicaci√≥n para habilitar Kubernetes a trav√©s de la ruta "Settings (√≠cono) -> Kubernetes -> Enable Kubernetes":  
![Habilitar Kubernetes](./assets/kubernetes_enable.png)
Y luego de clickear "Apply & Restart", tomar√° un tiempo en instalar todos los paquetes y dependencias de internet (necesitar√°n conexi√≥n obligatoriamente). Aunque descuiden, este proceso solo tarda la primera vez. Al final de todo les saldr√° el mensaje confirmaci√≥n.  
![Kubernetes habilitado](./assets/kubernetes_ready.png)

**Inslar kubectl (sino viene con Docker Desktop)**  
```
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
```
Abran un terminal, pueden hacerlo desde vscode o la terminal b√°sica de su sistema operativo. En mi caso, estar√© usando Warp que tiene autocompletado y sugerencias con AI:  
![Descarga de Kubectl](./assets/kubectl_install.png)

**Verificiar instalaci√≥n**  
El √∫ltimo paso, verificar la correcta instalaci√≥n de todos los componentes.  
![Verificacion k8s](./assets/verificacion_k8s.png)

#### B. Configuraci√≥n inicial
```
# Crear namespace para el proyecto
kubectl create namespace { el nombre de tu proyecto }

# Verificamos que Kubernetes est√© corriendo
kubectl get nodes
```
Y este deber√≠a ser el resultado, importante tener el Docker Desktop abierto:  
![Namespace y Nodos](./assets/configuracion_inicial.png)

### 5. Demo t√©cnica
Con la finalidad de demostrar la funcionlidad de Kubernetes, estaremos aplicando su uso al software "Singletone". Un software de valoraci√≥n musical en el que cada usuario almacena valoraciones de √°lbumes musicales, siendo su principal diferenciador el que es un gestor de contenido m√°s que una red social. En singletone, solo importa "tu" opini√≥n.

Lo √∫nico a considerar es que por el alcance de la actividad, estaremos reduciendo las funcionlidades a una sola, as√≠ como la configuraci√≥n completa de ciertas herramientas. V√©ase el frontend y backend que tendr√°n archivos m√°s sencillos, contrario a cuando se hace un aplicativo masivo.

#### A. Estructura de Carpetas
Al momenta de manejar contenedores, es de suma importancia mantener una estructura de carpetas impecable. Pues, estaremos usando rutas al momento de establecer las configuraciones. Recomendamos esta para la demo:  
![Estructura de carpetas](./assets/estructura_carpetas.png)

#### B. Backend
Como se ve en la carpeta, debemos de configurar 3 archivos importantes.  
**Dockerfile**  
Este nos ayudar√° a dockerizar el microservicio a futuro.  
![dockerfile_frontend](./assets/backend_dockerfile.png)

**Package.json**  
Encargado de gestionar dependencias y scripts.  
![package_frontend](./assets/backend_package.png)

**Server.js**
Aqu√≠ configuraremos las rutas y servicios APIs que ofrecer√° nuestro backend.
```
const express = require('express');
const { Pool } = require('pg');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3001;

// Configuraci√≥n de PostgreSQL
const pool = new Pool({
    host: process.env.DB_HOST || 'postgres-service',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'singletone',
    user: process.env.DB_USER || 'admin',
    password: process.env.DB_PASSWORD || 'password123'
});

app.use(cors());
app.use(express.json());

// Inicializar base de datos
async function initDB() {
    try {
        await pool.query(`
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            nickname VARCHAR(50) UNIQUE NOT NULL,
            plan VARCHAR(20) DEFAULT 'gratuito',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        `);
        console.log('Tabla users creada');
    } catch (err) {
        console.error('Error creando tabla:', err);
    }
}

// Rutas API
app.get('/health', (req, res) => {
    res.json({ status: 'OK', service: 'singletone-backend' });
});

app.get('/api/users', async (req, res) => {
    try {
        const result = await pool.query('SELECT * FROM users ORDER BY created_at DESC');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching users:', err);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});

app.post('/api/users', async (req, res) => {
    const { name, email, nickname } = req.body;
    
    try {
        const result = await pool.query(
        'INSERT INTO users (name, email, nickname) VALUES ($1, $2, $3) RETURNING *',
        [name, email, nickname]
        );
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error creating user:', err);
        if (err.code === '23505') {
        res.status(400).json({ error: 'Email o nickname ya existe' });
        } else {
        res.status(500).json({ error: 'Error interno del servidor' });
        }
    }
});

setTimeout(() => {
    initDB().then(() => {
        app.listen(PORT, '0.0.0.0', () => {
        console.log(`üöÄ Backend corriendo en puerto ${PORT}`);
        });
    });
}, 5000);
```

#### C. Frontend
**Dockerfile**
Mismo procedimiento.  
![dockerfile_frontend](./assets/frontend_dockerfile.png)

**Pacakge.json**
Mismo procedimiento.  
![pacakge_frontend](./assets/frontend_package.png)

**Index.astro**  
Aqu√≠ configuramos lo que ver√° el usuario. Hemos adjunto la imagen del body; sin embargo, en el repositorio de la demo puedes ver el c√≥digo completo.
![index_frontend](./assets/frontend_index.png)


## Integrantes 02: Adri√°n Duarte
{ ingresar tu contenido debajo y cualquier imagen o v√≠deo o adjunto, lo pones en la carpeta /assets ‚Äî esto es solo un placeholder, lo eliminas luego }

## Integrantes 03: Alejandro Ch√°vez
{ ingresar tu contenido debajo y cualquier imagen o v√≠deo o adjunto, lo pones en la carpeta /assets ‚Äî esto es solo un placeholder, lo eliminas luego }

## Integrantes 04: Angel Alcal√°
{ ingresar tu contenido debajo y cualquier imagen o v√≠deo o adjunto, lo pones en la carpeta /assets ‚Äî esto es solo un placeholder, lo eliminas luego }

## Integrantes 05: Erick Valderrama
{ ingresar tu contenido debajo y cualquier imagen o v√≠deo o adjunto, lo pones en la carpeta /assets ‚Äî esto es solo un placeholder, lo eliminas luego }
