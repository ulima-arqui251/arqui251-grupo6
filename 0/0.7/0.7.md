# 0.7. Temas Individuales por Integrante (Informes)
- [Volver al índice](/0/0.md)

Sample content for section 0.7.

## Integrantes 01: Rodrigo De los Ríos
***Arquitectura de Microservicios con Kubernetes***
### 1. Desarrollo conceptual
#### A. ¿Qué es la Arquitectura de Microservicios?  
La arquitectura de microservicios es un patrón de diseño que estructura una aplicación como una colección de servicios pequeños, independientes y débilmente acoplados. Cada microservicio se ejecuta en su propo proceso y se comunica mediante APIs bien definidas, típicamente HTTP/REST o messaging asíncrono.  
![Arquitectura Monolítica vs Arquitectura de Microservicios](./assets/mono_microservi.jpeg)  

#### B. Características principales  

- **Descentralización**: Cada servicio maneja su propia base de datos y lógica de negocio.
- **Independencia**: Los servicios pueden ser desarrollados, desplegados y escalados independientemente.
- **Responsabilidad única**: Cada microservicio tiene una función específica y bien definida.
- **Tolerancia a fallos**: El fallo de un servicio no compromete toda la aplicación.
- **Tecnología agnóstica**: Cada servicio puede usar diferentes tecnologías y lenguajes.

#### C. Importancia y utilidad
***Ventajas:***
- **Escalabilidad granular**: Escalar solo los componentes que lo necesiten.
- **Desarrollo paralelo**: Equipos independientes trabajando en diferentes servicios.
- **Despliegue independiente**: Actualizaciones sin afectar el sistema completo.
- **Resiliencia**: Aislamiento de fallos entre servicios.
- **Flexibilidad tecnológica**: Libertad de elegir la mejor tecnología para cada servicio.

***Limitaciones:***
- **Complejidad operacional**: Gestión de múltiples servicios y comunicación.
- **Latencia de red**: Comunicación entre servicios introduce overhead.
- **Consistencia de datos**: Transacciones distribuidas son complejas.
- **Monitoreo**: Necesidad de observabilidad avanzada.
- **Testing**: Pruebas de integración más complejas.

#### D. Por qué usar Microservicios  
Los microservicios resultan especialmente útiles cuando una aplicación cuenta con múltiples dominios de negocio claramente definidos, requiere que sus componentes escalen de forma independiente, involucra a diferentes equipos trabajando en distintas partes del sistema, necesita flexibilidad para adoptar nuevas tecnologías o demanda una alta disponibilidad y resiliencia.

#### E. Casos prácticos
- **Netflix**: Miles de microservicios para streaming, recomendaciones, facturación.
- **Amazon**: Servicios independientes para catálogo, pagos, envíos, reviews.
- **Spotify**: Microservicios para música, playlists, usuarios, recomendaciones.
- **Uber**: Servicios separados para usuarios, conductores, pagos, mapas.  

![Casos prácticos](./assets/casos_practicos.jpg)  

### 2. Contexto de Solución
#### A. Situación Actual: Singletone como Monolito

Actualmente, Singletone está diseñada como una aplicación monolítica con 6 módulos principales:

- **Gestión de usuarios** —— Registro, autenticación, perfiles.
- **Visualización de perfil** —- Dashboard personal y estadísticas.
- **Exploración musical** -— Búsqueda y descubrimiento.
- **Gestión de biblioteca** —- Administración de música personal.
- **Gestión de recomendaciones** —- Sistema de ML para sugerencias.
- **Gestión de planes** -— Suscripciones y pagos.

#### B. Problemas Identificados
**Escalabilidad Limitada**
El módulo de recomendaciones, al ser intensivo en machine learning, demanda más recursos que otros componentes del sistema; además, la búsqueda musical puede experimentar picos de tráfico de forma independiente, y las funciones premium presentan patrones de uso distintos, lo que refuerza la necesidad de una arquitectura flexible y escalable.

**Complejidad de Desarrollo**
Cuando equipos distintos trabajan sobre la misma base de código, pueden surgir conflictos y cuellos de botella que dificultan el desarrollo ágil. Además, los despliegues se vuelven más arriesgados, ya que un cambio puede afectar a toda la aplicación. Esta estructura monolítica también limita la posibilidad de experimentar con nuevas tecnologías, al estar todo estrechamente acoplado.

**Limitaciones Técnicas**
Contar con una base de datos central compartida por todos los módulos puede generar cuellos de botella y dificultar la independencia entre componentes. Además, utilizar una única tecnología —probablemente en un enfoque monolítico basado en un solo framework— limita la flexibilidad del sistema. Este tipo de arquitectura también suele presentar restricciones a la hora de escalar horizontalmente, afectando su capacidad de respuesta ante una alta demanda.

### C. Benficios esperados
**Para el negocio**
- Tiempo de desarrollo reducido: Equipos paralelos trabajando independientemente.
- Experimentación segura: Cambios en recomendaciones sin afectar otros servicios.
- Escalabilidad económica: Escalar solo lo que necesita más recursos.

**Para los usuarios**
- Mejor rendimiento: Servicios optimizados individualmente.
- Mayor disponibilidad: Fallos aislados no tumban toda la plataforma.
- Nuevas funcionalidades: Desarrollo más ágil de features.

**Para el equipo técnico**
- Flexibilidad tecnológica: Python para ML, Node.js para APIs, Go para performance.
- Despliegues independientes: Actualizaciones sin downtime.
- Monitoreo granular: Observabilidad por servicio.

### 3. ¿Qué es Kubernetes y cómo funciona?
Kubernetes (K8s) es una plataforma de orquestación de contenedores open-source que automatiza el despliegue, escalado y gestión de aplicaciones containerizadas. Originalmente desarrollado por Google, se basa en más de 15 años de experiencia ejecutando cargas de trabajo de producción a escala.
![Arquitectura común de Kubernetes](./assets/cluster_pods.jpeg)

#### A. Componentes principales de Kubernetes
**Controle Plane (Panel de Control)**:
- API Server: Punto de entrada para todas las operaciones del cluster.
- etcd: Base de datos distribuida que almacena la configuración del cluster.
- Scheduler: Decide en qué nodos ejecutar los pods.
- Controller Manager: Ejecuta los controladores que regulan el estado del cluster.

**Worker nods**:
- kubelet: Agente que se ejecuta en cada nodo y gestiona los pods.
- kube-proxy: Componente de red que mantiene las reglas de red.
- Container Runtime: Motor que ejecuta los contenedores (Docker, containerd).

![k8s arquitecura](./assets/k8s_architecture.png)

#### B. Conceptos fundamentales
**Pods:**
- Unidad más pequeña desplegable en Kubernetes.
- Puede contener uno o más contenedores que comparten red y almacenamiento.
- Los contenedores en un pod siempre se ejecutan en el mismo nodo.

**Services:**
- Abstracción que define un conjunto lógico de pods.
- Proporciona descubrimiento de servicios y balanceado de carga.
- Tipos: ClusterIP, NodePort, LoadBalancer, ExternalName.

**Deployments:**
- Gestiona el despliegue y actualización de aplicaciones.
- Asegura que el número deseado de réplicas esté ejecutándose.
- Facilita rolling updates y rollbacks.

**ConfigMaps y Secrets:**
- ConfigMaps: Almacenan datos de configuración no confidenciales.
- Secrets: Almacenan información sensible como passwords y tokens.

**Ingress:**
- Gestiona el acceso externo a los servicios del cluster.
- Proporciona balanceado de carga, terminación SSL y virtual hosting.

#### C. Cómo Kubernetes Orquesta los Microservicios
**1. Service discovery**
```
# Los servicios se registran automáticamente en DNS interno
user-service.default.svc.cluster.local
music-service.default.svc.cluster.local
``` 

**2. Load balancing**
- Kubernetes distribuye automáticamente el tráfico entre réplicas.
- Detecta pods no saludables y los excluye del balanceado.

**3. Auto-scaling**
- Horizontal Pod Autoscaler (HPA): Escala pods basado en CPU/memoria.
- Vertical Pod Autoscaler (VPA): Ajusta recursos de pods.
- Cluster Autoscaler: Añade/remueve nodos según demanda.

**4. Health checks**
- Liveness Probes: Determina si un pod está vivo
- Readiness Probes: Determina si un pod está listo para recibir tráfico
- Startup Probes: Para aplicaciones con tiempos de inicio lentos

### 4. Consideraciones técnicas
A continuación, se detalla las consideraciones que debe tener el programador antes de comenzar la implementación de Kubernetes. Este proceso incluirá tanto la descarga de Kubernetes y Docker, como verificar que el proyecto creado se encuentre corriendo.

### A. Requisitos previos
**Instalar Docker Desktop**  

Para ello nos dirigimos a la siguiente URL: [Docker Desktop](https://www.docker.com/products/docker-desktop/) y descargamos la versión compatible con nuestro sistema operativo (En caso uses macOS con chip M, descarga la opción "Apple Silicon". De lo contrario, ve por "Intel Chip").  

![Docker Desktop download](./assets/docker_desktop_download.png)

Con ello listo, abrimos la aplicación para habilitar Kubernetes a través de la ruta "Settings (ícono) -> Kubernetes -> Enable Kubernetes":  
![Habilitar Kubernetes](./assets/kubernetes_enable.png)
Y luego de clickear "Apply & Restart", tomará un tiempo en instalar todos los paquetes y dependencias de internet (necesitarán conexión obligatoriamente). Aunque descuiden, este proceso solo tarda la primera vez. Al final de todo les saldrá el mensaje confirmación.  
![Kubernetes habilitado](./assets/kubernetes_ready.png)

**Inslar kubectl (sino viene con Docker Desktop)**  
```
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
```
Abran un terminal, pueden hacerlo desde vscode o la terminal básica de su sistema operativo. En mi caso, estaré usando Warp que tiene autocompletado y sugerencias con AI:  
![Descarga de Kubectl](./assets/kubectl_install.png)

**Verificiar instalación**  
El último paso, verificar la correcta instalación de todos los componentes.  
![Verificacion k8s](./assets/verificacion_k8s.png)

#### B. Configuración inicial
```
# Crear namespace para el proyecto
kubectl create namespace { el nombre de tu proyecto }

# Verificamos que Kubernetes esté corriendo
kubectl get nodes
```
Y este debería ser el resultado, importante tener el Docker Desktop abierto:  
![Namespace y Nodos](./assets/configuracion_inicial.png)

### 5. Demo técnica
Con la finalidad de demostrar la funcionlidad de Kubernetes, estaremos aplicando su uso al software "Singletone". Un software de valoración musical en el que cada usuario almacena valoraciones de álbumes musicales, siendo su principal diferenciador el que es un gestor de contenido más que una red social. En singletone, solo importa "tu" opinión.

Lo único a considerar es que por el alcance de la actividad, estaremos reduciendo las funcionlidades a una sola, así como la configuración completa de ciertas herramientas. Véase el frontend y backend que tendrán archivos más sencillos, contrario a cuando se hace un aplicativo masivo.

#### A. Estructura de Carpetas
Al momenta de manejar contenedores, es de suma importancia mantener una estructura de carpetas impecable. Pues, estaremos usando rutas al momento de establecer las configuraciones. Recomendamos esta para la demo:  
![Estructura de carpetas](./assets/estructura_carpetas.png)

## Integrantes 02: Adrián Duarte
{ ingresar tu contenido debajo y cualquier imagen o vídeo o adjunto, lo pones en la carpeta /assets — esto es solo un placeholder, lo eliminas luego }

## Integrantes 03: Alejandro Chávez

# Observabilidad y monitoreo de aplicaciones
En el desarrollo de software moderno, especialmente en entornos distribuidos y basados en microservicios, garantizar la estabilidad, el rendimiento y la rápida detección de problemas es crucial. Aquí es donde entran en juego la observabilidad y el monitoreo, dos conceptos interrelacionados pero distintos que permiten a los equipos de desarrollo y operaciones mantener sistemas confiables y eficientes.

## Monitoreo
El monitoreo se refiere al proceso de recopilar, analizar y visualizar datos sobre el comportamiento de un sistema para detectar anomalías, evaluar el rendimiento y generar alertas cuando ocurren problemas conocidos.

### Objetivos del monitoreo
- Deteción de fallos: Identificar errores a tiempo real, como por ejemplo caídas del servidor o degradación del rendimiento.
- Alertas proactivas: Identificar problemas y notificarlos antes de que los usuarios puedan verse afectados.
- Tendencia histórica: Analizar las métricas a lo largo del tiempo para facilitar la toma de decisiones
- Cumplimiento de acuerdos a nivel de servicio: Asegurar que el sistema cumple con proveer el nivel de servicio acordado.

### Tipos de monitoreo
- De infraestructura: Supervisa los recursos del sistema (CPU, memoria, disco, red, servidores).
- De aplicaciones: Supervisa el rendimiento de las aplicaciones, evaluando que estas funcionen con regularidad, buscando errores o problemas de latencia.
- De usuarios: Monitorea la experiencia del usuario final que usa el sistema.
- De logs: Recolecta y analiza registros de eventos, esto incluye cosas como solicitudes y errores junto con su información detallada.

## Observabilidad
A diferencia del monitoreo, el cual se enfoca en problemas conocidos, la observabilidad se enfoca en descubrir nuevos problemas de los cuales no se tiene registro previo, mediante el análisis de datos entrantes y salientes del sistema. Facilita la resolución de problemas, mejora el rendimiento y la confiabilidad del sistema, y permite una optimización proactiva.

La observabilidad cuenta con tres pilares fundamentales:
- Métricas: Datos numéricos que cuantifican aspectos clave de un sistema, tales como el rendimiento, uso de recursos, latencia y tasa de errores. El uso de métricas permite monitorear el estado de un sistema en el tiempo e identificar patrones y tendencias.
- Logs/Registros: Mensajes generados el sistema que describen eventos que toman lugar en este. Estos registros ayudan a comprender qué está sucediendo dentro del sistema y bajo que contexto para así identificar errores y depurar problemas.
- Trazas: Registros de eventos relacionados entre diferentes componentes de un mismo sistema, mostrando el flujo del evento a través de múltiples servicios del sistema. Las trazas permiten rastrear la raíz de un problema y entender cómo las diferentes partes de un sistema interactúan entre sí durante este evento. Especialmente útil en una arquitectura de microservicios.

## Diferencias entre monitoreo y observabilidad
|  | **Monitoreo** | **Observabilidad** |
|------------------|------------------|------------------|
Enfoque Principal | Recopilar datos para identificar anomalías en el sistema | Investigar la causa de las anomalías en el sistema
Sistemas Involucrados | Mayormente sistemas independientes | Sistemas múltiples y dispares
Nivel de trazabilidad | Limitado a un mismo sistema | Disponible cuando las señales se transmiten entre sistemas dispares
Resultados | Que error sucedió y cuando | Por qué sucedió el error y como

## Sentry
Sentry es una plataforma del tipo SaaS enfocada en la observabilidad y monitoreo, especializada en detección de errores en tiempo real de aplicaciones, ayudando a los desarrolladores a identificar la causa, frecuencia e impacto de estos. Sentry además permite monitorear el rendimiento de las aplicaciones. Sentry es compatible con una amplia gama de lenguajes de programación, por lo que es ideal para cualquier tipo de proyecto, además es utilizado por grandes empresas como Disney y Microsoft.

### Ejemplo de flujo de trabajo con Sentry
| **Paso** | **Acción** | **Resultado** |
|------------------|------------------|------------------|
1 | El usuario hace clic en un botón | Se lanza un error
2 | Sentry captura el error | El error aparece en el dashboard
3 | El equipo recibe una alerta	| Se prioriza la solución
4 | Se implementa una solución | Sentry monitorea si el error reaparece

## Consideraciones técnicas
### Requisitos básicos:
- Tener una cuenta en sentry.io
- SDK compatible con el lenguaje usado en tu proyecto
- DNS de tu proyecto en Sentry

### Instalación
Una vez que creas tu proyecto en la página de Sentry, se proporciona documentación simple y específica sobre como instalar e iniciar el servicio de Sentry en tu aplicación, dependiendo de que lenguaje de programación se este utilizando.

### Bloqueadores de anuncios y rastreadores
Cuando desplegamos una aplicación web, algunos usuarios podrían hacer uso de extensiones o navegadores especiales para bloquear anuncios y otros rastreadores, en algunos casos estos pueden dificultar el monitoreo por parte de Sentry. Para asegurarse de que la aplicación este enviando la información a Sentry con normalidad, se puede utilizar la consola del navegdor y en la pestaña "Network" buscar las solicitudes a Sentry.

## Demo de detección de errores con Sentry
https://github.com/AleGCC/arqi-demo-sentry

## Integrantes 04: Angel Alcalá
{ ingresar tu contenido debajo y cualquier imagen o vídeo o adjunto, lo pones en la carpeta /assets — esto es solo un placeholder, lo eliminas luego }

## Integrantes 05: Erick Valderrama
{ ingresar tu contenido debajo y cualquier imagen o vídeo o adjunto, lo pones en la carpeta /assets — esto es solo un placeholder, lo eliminas luego }
