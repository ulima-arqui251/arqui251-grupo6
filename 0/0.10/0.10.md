# 0.10. Temas Individuales por Integrante - Parte 2 (Informes)
- [Volver al √≠ndice](/0/0.md)

## Integrantes 01: Rodrigo De los R√≠os
Escriban su desarollo { incluye el enlace a repositorio externo d√≥nde hiciste la demo }

‚Äî‚Äî Referencia 01: https://www.intersystems.com/es/recursos/sharding-bbdd/

{ hablar de la situaci√≥n actual de los datos masivos, la soluci√≥n que ofrece Sharding, ejemplo f√°cil de c√≥mo funciona shrading (maletas ) }

## Integrantes 02: Adri√°n Duarte
Escriban su desarollo { incluye el enlace a repositorio externo d√≥nde hiciste la demo }

## Integrantes 03: Alejandro Ch√°vez

### Estrategias de Consistencia de Cache

#### Desarrollo Conceptual

En sistemas distribuidos y aplicaciones de alto rendimiento, la cach√© act√∫a como una capa intermedia entre los usuarios y el almacenamiento principal, reduciendo la latencia y mejorando los tiempos de respuesta. La consistencia de cache se refiere a la sincronizaci√≥n entre los datos de una cache y el almacenamiento principal. En sistemas distribuidos, mantener esta consistencia es crucial para garantizar que los clientes siempre obtengan datos actualizados, incluso cuando se realizan m√∫ltiples operaciones de lectura y escritura al mismo tiempo.

#### Estrategias principales

- Cache-Aside
    - Descripci√≥n: La aplicaci√≥n gestiona directamente la cache. Primero consulta la cache y si no encuentra los datos, los busca en la base de datos principal, los almacena en cache y luego los devuelve.
    - Ventajas: Simple de implementar, eficiente para cargas de trabajo con muchas lecturas.
    - Desventajas: Puede generar inconsistencia temporal entre cache y DB.

- Write-Through
    - Descripci√≥n: Cada escritura pasa primero por la cache y luego se escribe sincr√≥nicamente en la base de datos.
    - Ventajas: Garantiza que la cache siempre est√© actualizada.
    - Desventajas: Mayor latencia en operaciones de escritura.

- Write-Behind
    - Descripci√≥n: Las escrituras se realizan primero en cache y luego, de manera as√≠ncrona, se propagan a la base de datos.
    - Ventajas: Mejor rendimiento en escrituras.
    - Desventajas: Riesgo de p√©rdida de datos si falla la cache antes de propagar los cambios.

- Refresh-Ahead
    - Descripci√≥n: El sistema predice qu√© datos ser√°n necesitados y los actualiza proactivamente en cache antes de que expire su TTL.
    - Ventajas: Reduce cache misses.
    - Desventajas: Complejidad en la implementaci√≥n, puede consumir recursos innecesariamente.

#### Consideraciones T√©cnicas

Al seleccionar una estrategia de consistencia de cache, el primer aspecto t√©cnico a evaluar es el patr√≥n de acceso a los datos. Sistemas con un ratio de 90% lecturas y 10% escrituras se benefician claramente de estrategias como Cache-Aside o Refresh-Ahead, donde se optimiza el acceso r√°pido a datos frecuentemente le√≠dos. Por el contrario, sistemas con operaciones de escritura intensivas como plataformas de transacciones financieras pueden requerir enfoques como Write-Through para garantizar consistencia inmediata.

Un segundo factor cr√≠tico es el tama√±o promedio de los datos almacenados en cache. Estrategias como Write-Behind, que mantienen datos en cache por per√≠odos prolongados, pueden ser problem√°ticas cuando se trabaja con grandes vol√∫menes de datos que superan la capacidad de la memoria cache disponible. En estos casos, es esencial implementar pol√≠ticas de evicci√≥n eficientes (LRU, LFU) y considerar mecanismos de compresi√≥n.

La eficacia de cualquier estrategia depende de una configuraci√≥n cuidadosa de par√°metros t√©cnicos:

- TTL (Time-To-Live):
    - Valores demasiado altos pueden servir datos obsoletos
    - Valores demasiado bajos generan excesivas recargas
    - Soluci√≥n h√≠brida: TTL base + invalidaci√≥n activa para cambios cr√≠ticos

- Tama√±o de Cache:
    - Debe calcularse seg√∫n el working set de la aplicaci√≥n
    - Monitorear continuamente la tasa de hits/misses
    - Implementar auto-scaling para cargas variables

- Pol√≠ticas de Evicci√≥n:
    - LRU (Least Recently Used): Ideal para acceso temporalmente localizado
    - LFU (Least Frequently Used): Mejor para patrones de acceso estables
    - FIFO (First In First Out): Simple pero menos eficiente

#### Demo de detecci√≥n de errores con Sentry
- Asegurarse de usar la rama "master"
https://github.com/AleGCC/demo-cachealejch/tree/master

## Integrantes 04: Angel Alcal√°

### Benchmarking de LLMs para Generaci√≥n de C√≥digo

#### Desarrollo Conceptual

Los modelos de lenguaje de gran escala (LLMs, por sus siglas en ingl√©s) se han convertido en herramientas clave para la generaci√≥n autom√°tica de c√≥digo, permitiendo desde el autocompletado hasta la creaci√≥n de funciones complejas a partir de descripciones en lenguaje natural. Dado el amplio abanico de modelos disponibles, el benchmarking o evaluaci√≥n comparativa de estos modelos se vuelve esencial para entender su desempe√±o en tareas espec√≠ficas y tomar decisiones informadas al momento de integrarlos en flujos de trabajo de desarrollo.

El benchmarking de LLMs implica medir su precisi√≥n, eficiencia y utilidad pr√°ctica en contextos reales de programaci√≥n. Esto puede abarcar desde la calidad sint√°ctica y sem√°ntica del c√≥digo generado, hasta el cumplimiento de especificaciones, compatibilidad con lenguajes espec√≠ficos, y la habilidad para depurar errores o completar c√≥digo parcial.

#### Estrategias principales

- **Few-Shot Learning**
    - **Descripci√≥n**: Se proporciona al modelo unos pocos ejemplos como contexto antes de realizar una tarea espec√≠fica de generaci√≥n de c√≥digo.
    - **Ventajas**: Reduce la necesidad de entrenamiento adicional, adaptable a m√∫ltiples dominios.
    - **Desventajas**: Sensible al orden y calidad de los ejemplos; puede ser inconsistente.

- **Zero-Shot Learning**
    - **Descripci√≥n**: El modelo genera c√≥digo a partir de una descripci√≥n sin ejemplos previos, confiando √∫nicamente en su conocimiento preentrenado.
    - **Ventajas**: Ideal para tareas generales; no requiere preparaci√≥n previa.
    - **Desventajas**: Menor precisi√≥n en dominios altamente especializados.

- **Code Completion**
    - **Descripci√≥n**: Eval√∫a la capacidad del modelo para completar bloques de c√≥digo parcialmente escritos, simulando casos de uso reales en editores de texto.
    - **Ventajas**: Muy √∫til para desarrolladores; mejora la productividad.
    - **Desventajas**: Puede producir resultados err√≥neos si el contexto es ambiguo o incompleto.

- **Bug Fixing y Refactoring**
    - **Descripci√≥n**: Se mide la habilidad del modelo para identificar errores y proponer soluciones o mejoras estructurales al c√≥digo.
    - **Ventajas**: Aporta valor en mantenimiento de software.
    - **Desventajas**: Dif√≠cil evaluar objetivamente; algunas sugerencias pueden ser sint√°cticamente correctas pero funcionalmente err√≥neas.

#### Consideraciones T√©cnicas

Al seleccionar un LLM para generaci√≥n de c√≥digo, el primer aspecto t√©cnico a considerar es el **lenguaje de programaci√≥n objetivo**. Algunos modelos est√°n optimizados para lenguajes como Python o JavaScript, mientras que su rendimiento disminuye con lenguajes menos comunes o altamente tipados como Rust o Haskell.

Otro factor determinante es el **tama√±o del contexto** que el modelo puede manejar. Modelos como GPT-4 o Claude-3 permiten trabajar con ventanas de contexto extendidas, √∫tiles en proyectos con m√∫ltiples dependencias y estructuras complejas.

La evaluaci√≥n debe realizarse con m√©tricas objetivas y subjetivas:

- **Exactitud Sem√°ntica**:
    - ¬øEl c√≥digo cumple con la especificaci√≥n solicitada?
    - ¬øProduce el resultado esperado al ser ejecutado?

- **Calidad Sint√°ctica**:
    - ¬øEl c√≥digo es v√°lido seg√∫n el compilador/int√©rprete?
    - ¬øSigue buenas pr√°cticas de estilo?

- **Tiempo de Respuesta y Costo Computacional**:
    - Importante en aplicaciones de uso intensivo o en tiempo real.
    - Se deben balancear latencia, costo por token y tama√±o del modelo.

- **Tolerancia a Errores**:
    - ¬øEl modelo entiende y corrige entradas incompletas o ambiguas?
    - ¬øEs robusto frente a instrucciones contradictorias?

#### Herramientas y Frameworks de Evaluaci√≥n

- **HumanEval**:
    - Conjunto de pruebas creado por OpenAI para medir la capacidad de resoluci√≥n de problemas mediante generaci√≥n de c√≥digo en Python.

- **CodeXGLUE**:
    - Benchmark open-source que eval√∫a m√∫ltiples tareas como generaci√≥n, traducci√≥n y clasificaci√≥n de c√≥digo.

- **MBPP (Mostly Basic Programming Problems)**:
    - Eval√∫a el rendimiento de modelos en problemas simples pero pr√°cticos, ideales para modelar tareas de principiantes o automatizaci√≥n b√°sica.

- **BigCode y EvalPlus**:
    - Enfocados en evaluaci√≥n reproducible, escalable y segura de modelos de c√≥digo abierto y cerrado.

---

El benchmarking riguroso y bien dise√±ado no solo permite identificar fortalezas y debilidades de los LLMs, sino que tambi√©n orienta su uso hacia escenarios m√°s eficientes y realistas en entornos de desarrollo profesional.

#### Demo del c√≥digo

La presente demo tiene como finalidad realizar un benchmark b√°sico de modelos de lenguaje entrenados para la generaci√≥n de c√≥digo, usando modelos open-source gratuitos como Hugging Face. Para ser mas espec√≠ficos, se evaluar√° el modelo StarCoder, el cual es dise√±ado para tareas de programaci√≥n.

###### Requisitos previos

Primero, se debe instalar transformers torch en la terminal para la funcionalidad del c√≥digo

```
pip install transformers torch
```
Posteriormente se deber√° implementar el siguiente c√≥digo en cualquier
IDE

```python
from transformers import pipeline
import time

# Cargar modelo gratuito
print("üîÑ Cargando modelo...")
generator = pipeline("text-generation", model="Salesforce/codegen-350M-multi")
print("‚úÖ Modelo cargado.\n")

# Dataset de evaluaci√≥n
benchmarks = [
    {
        "prompt": "Escribe una funci√≥n en Python que sume dos n√∫meros",
        "expected": "def suma(a, b):\n    return a + b"
    },
    {
        "prompt": "Crea una funci√≥n para calcular el factorial de un n√∫mero",
        "expected": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)"
    },
    {
        "prompt": "Haz una funci√≥n que determine si un n√∫mero es par",
        "expected": "def es_par(n):\n    return n % 2 == 0"
    }
]

# Funci√≥n simple de comparaci√≥n
def exact_match(expected, generated):
    expected_clean = expected.strip().replace(" ", "").lower()
    generated_clean = generated.strip().replace(" ", "").lower()
    return expected_clean in generated_clean

# Evaluaci√≥n
aciertos = 0
total = len(benchmarks)

for i, bench in enumerate(benchmarks, start=1):
    print(f"üîç [{i}/{total}] Prompt: {bench['prompt']}")
    start = time.time()
    response = generator(bench['prompt'], max_new_tokens=100, do_sample=False)[0]['generated_text']
    end = time.time()

    # Limpiar solo el bloque de c√≥digo generado
    generated_code = response.split(bench['prompt'])[-1].strip()
    
    # Evaluar
    match = exact_match(bench["expected"], generated_code)
    resultado = "‚úÖ Correcto" if match else "‚ùå Incorrecto"
    print(f"Resultado: {resultado}")
    print("C√≥digo generado:\n", generated_code)
    print(f"‚è±Ô∏è Tiempo de respuesta: {round(end - start, 2)}s\n")

    if match:
        aciertos += 1

# Resumen
print("üìä Resultado final del benchmark:")
print(f"Aciertos: {aciertos}/{total}")
print(f"Precisi√≥n: {round((aciertos / total) * 100, 2)}%")

```

El presente c√≥digo carga el modelo codegen-350M-multi de Hugging Face, un generador de c√≥digo abierto entrenado por Salesforce. Luego, genera c√≥digo a partir de una instrucci√≥n en lenguaje natural utilizando un pipeline de generaci√≥n de texto. Finalmente, imprime el c√≥digo generado por el modelo.



## Integrantes 05: Erick Valderrama

### Arquitectura Hexagonal: Separaci√≥n de la l√≥gica de negocio de la infraestructura - Puertos y Adaptadores

#### Desarrollo Conceptual

La Arquitectura Hexagonal, tambi√©n conocida como Arquitectura de Puertos y Adaptadores, fue propuesta por Alistair Cockburn en 2005 como respuesta a un problema estructural recurrente en el desarrollo de software: la fuerte dependencia de la l√≥gica de negocio respecto a tecnolog√≠as o recursos externos, como frameworks web, bases de datos o interfaces gr√°ficas (Cockburn, 2005).

Este patr√≥n propone un enfoque donde la aplicaci√≥n se organiza desde adentro hacia afuera. Coloca el dominio central (reglas de negocio y entidades) en el n√∫cleo del sistema y conect√°ndolo con el mundo exterior a trav√©s de interfaces claramente definidas llamadas puertos y sus implementaciones concretas denominadas adaptadores.

El objetivo central de esta arquitectura es lograr una separaci√≥n estricta de problemas, asegurar que los elementos de infraestructura cambian con mayor frecuencia no afecten directamente la l√≥gica del negocio. Esta separaci√≥n permite construir sistemas m√°s modulares, mantenibles, testeables y resistentes a cambios tecnol√≥gicos. En palabras de Martin Fowler (2002), ‚Äúla clave de un buen dise√±o arquitect√≥nico es aislar las partes que cambian de las que no cambian‚Äù.

**¬øC√≥mo funciona?**

En el campo, los puertos son interfaces que definen "contratos" de comunicaci√≥n que el n√∫cleo de la aplicaci√≥n necesita para interactuar con servicios externos o exponer funcionalidades. Un ejemplo es que se pueden definir puertos como "guardarCliente()" o "enviarCorreo()". Los adaptadores en cambio son las implementaciones concretas de estos puertos, un adaptador puede utilizar PostgreSQL para persistir datos, otro puede enviar correos mediante una API externa como SendGrid.

A esta inversi√≥n de control se le llama Dependency Inversion Principle (DIP), uno de los principios SOLID m√°s importantes en dise√±o de software. Seg√∫n este principio, el c√≥digo de alto nivel (el dominio) no debe depender del c√≥digo de bajo nivel (como frameworks), sino que ambos deben depender de abstracciones (Martin, 2018).

**¬øC√≥mo se interrelacionan?**

Uno de los aspectos m√°s poderosos de la arquitectura hexagonal es que permite que componentes heterog√©neos, como un adaptador web en TypeScript, uno de persistencia en SQL, o incluso uno de l√≠nea de comandos en Bash, interact√∫en sin conflictos con el n√∫cleo de la aplicaci√≥n. Esta interrelaci√≥n exitosa es posible gracias a cuatro mecanismos fundamentales: la definici√≥n clara de puertos, el uso de interfaces como contratos, y la inversi√≥n de dependencias.

1. Contratos de comunicaci√≥n (puertos).-
El n√∫cleo de la aplicaci√≥n no conoce los detalles t√©cnicos de los adaptadores, solo conoce lo que espera de ellos, sus productos. Esto se logra mediante interfaces o abstracciones llamadas puertos. Por ejemplo, el dominio puede definir un puerto como *RepositorioDeTareas* que espera un m√©todo "guardar(tarea: Tarea): void". No importa si el adaptador implementa esto usando PostgreSQL, MongoDB, una API REST o un archivo plano: mientras respete la firma y comportamiento del puerto, ser√° compatible.

‚ÄúLos puertos act√∫an como un contrato de uso: el n√∫cleo sabe qu√© necesita, no c√≥mo se implementa‚Äù
‚Äî (Cockburn, 2005)

2. Implementaciones independientes (adaptadores).-
Cada adaptador se encarga de traducir su mundo externo al lenguaje que entiende el dominio. Lo importante es que todos estos adaptadores pueden estar escritos en distintos lenguajes, ejecutarse en distintos contextos o plataformas, y aun as√≠ interconectarse sin problemas, siempre que respeten el contrato del puerto. Este desacoplamiento permite desarrollar cada adaptador de forma independiente, incluso en tiempos distintos. Por ejemplo:
- Un adaptador HTTP convierte una petici√≥n JSON en un objeto Tarea y llama a crearTarea().
- Un adaptador CLI puede leer datos desde consola, convertirlos y pasarlos al n√∫cleo.
- Un adaptador de base de datos traduce un INSERT SQL a una llamada al puerto de persistencia.

3. Inversi√≥n de dependencias.-
Gracias al principio de inversi√≥n de dependencias (DIP), el n√∫cleo no depende de ning√∫n adaptador. Es el adaptador quien depende del n√∫cleo. Esto se facilita mediante inyecci√≥n de dependencias o mecanismos similares, donde el adaptador ‚Äúregistra‚Äù su implementaci√≥n y la conecta con el puerto definido por el dominio. As√≠, el n√∫cleo solo ve una abstracci√≥n, sin saber si lo que est√° detr√°s es un servicio en la nube, una funci√≥n local o una librer√≠a externa.

4. Traducci√≥n sem√°ntica.-
Otro ‚Äúsecreto‚Äù clave es que la arquitectura hexagonal enfatiza la responsabilidad de traducci√≥n en los bordes del sistema, no en el n√∫cleo. Este se mantiene limpio, sin l√≥gica t√©cnica ni preocupaciones externas. Este aislamiento sem√°ntico evita que el n√∫cleo ‚Äúse contamine‚Äù con detalles del mundo exterior, manteniendo su prop√≥sito puro y coherente. Esto significa que los adaptadores son los responsables de:

- Validar y transformar los datos de entrada.

- Convertir errores del dominio en c√≥digos HTTP o mensajes CLI.

- Formatear las respuestas para el mundo exterior.

**¬øC√≥mo debe construirse un sistema con arquitectura hexagonal?**

Una de las grandes virtudes de la arquitectura hexagonal es que organiza el desarrollo desde adentro hacia afuera, priorizando la l√≥gica de negocio por encima de los detalles t√©cnicos. Esto no es solo un enfoque estructural, sino tambi√©n una metodolog√≠a de trabajo. El flujo de desarrollo recomendado es el siguiente:

1. Desarrollo del N√∫cleo (Dominio).- 
El primer paso consiste en modelar el dominio de la aplicaci√≥n, es decir, las entidades, reglas de negocio y casos de uso. No conoce nada del exterior. Por ejemplo, en una aplicaci√≥n de gesti√≥n de tareas, se definir√° primero la entidad Tarea con sus reglas (no puede tener una fecha en el pasado, debe tener un t√≠tulo v√°lido, etc.) y los casos de uso como crearTarea() o completarTarea().

2. Definici√≥n de Puertos.-
Luego se identifican las interfaces que necesita el n√∫cleo para funcionar o exponer su funcionalidad. Estos puertos funcionan como contratos abstractos: definen qu√© espera el n√∫cleo sin decir c√≥mo debe hacerse. Por ejemplo, el caso de uso crearTarea() podr√≠a depender de un puerto RepositorioDeTareas, que define m√©todos como guardar(tarea: Tarea) o buscarPorId(id: string). Tambi√©n puede existir un puerto de salida como Notificador, que permite enviar mensajes a otros sistemas.

3. Implementaci√≥n de Adaptadores
Finalmente, se desarrollan los adaptadores, que son las implementaciones concretas de esos puertos. Un adaptador puede ser lo que sea. Cada adaptador se acopla al dominio, pero el dominio nunca se acopla a los adaptadores. Esto permite que, incluso si se decide cambiar de Express a Fastify, o de PostgreSQL a MongoDB, el n√∫cleo permanezca intacto.

*Este enfoque tambi√©n permite el desarrollo en paralelo de distintas partes del sistema, ya que los equipos pueden trabajar sobre adaptadores o interfaces gr√°ficas sin necesidad de modificar el dominio.*

**Comparaci√≥n con arquitecturas tradicionales**

A diferencia del enfoque en capas cl√°sico (Presentation ‚Üí Application ‚Üí Domain ‚Üí Infrastructure), donde las dependencias suelen fluir desde la capa superior hacia la base de datos, en la arquitectura hexagonal la dependencia es invertida: el dominio no conoce ni depende de ninguna tecnolog√≠a externa. Esta independencia t√©cnica convierte al dominio en una unidad f√°cilmente testeable, reutilizable y portable entre proyectos.

**Relaci√≥n con Clean Architecture y DDD**

Este patr√≥n influenci√≥ directamente a otras arquitecturas modernas, como la Clean Architecture de Robert C. Martin, y se alinea con los principios del Domain-Driven Design (DDD) propuestos por Eric Evans. En ambas corrientes, la prioridad es resguardar la l√≥gica de negocio frente al ruido de la infraestructura (Evans, 2003; Martin, 2018).

**Ejemplo ilustrativo**

Propongamos una estaci√≥n de radio como n√∫cleo, como dominio. Esta puede recibir se√±ales de varias fuentes: antena, internet o Bluetooth. Lo importante es que la estaci√≥n sabe c√≥mo interpretar una se√±al, pero no es necesario saber de donde viene para que funcione. Las fuentes son adaptadores, y la interfaz para recibir se√±al es el puerto. Si un d√≠a se cambia de antena a internet, la estaci√≥n sigue funcionando igual. Este es el coraz√≥n del enfoque hexagonal: el dominio no se ve afectado por los cambios en los canales de comunicaci√≥n.

**Aplicaciones pr√°cticas**

La arquitectura hexagonal es especialmente √∫til en:

- Aplicaciones que requieren larga vida √∫til o mantenimiento continuo.

- Sistemas orientados a microservicios, donde cada servicio tiene su propio dominio aislado.

- Casos donde se desea desarrollar la l√≥gica de negocio antes que la UI o el backend.

- Proyectos con alta necesidad de pruebas unitarias independientes del entorno.

**Ventajas principales**

- Testabilidad: al estar desacoplado, el n√∫cleo se puede probar sin infraestructura externa.

- Flexibilidad tecnol√≥gica: se pueden cambiar bases de datos, frameworks web o APIs sin tocar el dominio.

- Simplicidad conceptual: al dividir expl√≠citamente entre el qu√© (dominio) y el c√≥mo (adaptadores).

- Claridad de responsabilidades: cada componente tiene una funci√≥n espec√≠fica, lo que reduce la complejidad.

#### Limitaciones de la arquitectura hexagonal

Aunque la arquitectura hexagonal ofrece ventajas significativas, tambi√©n presenta ciertos desaf√≠os y limitaciones que deben ser considerados al adoptarla:

- Curva de aprendizaje inicial: Para equipos no familiarizados con principios como inversi√≥n de dependencias, inyecci√≥n de puertos y separaci√≥n de capas, la arquitectura puede parecer innecesariamente compleja al principio (Brown, 2016).

- Sobrecarga estructural en proyectos peque√±os: En aplicaciones simples o de corta duraci√≥n, el esfuerzo de crear puertos y adaptadores puede no justificarse, generando m√°s complejidad de la necesaria.

- Mantenimiento de m√∫ltiples adaptadores: En sistemas que requieren muchos canales de entrada/salida (REST, CLI, mensajer√≠a, etc.), mantener la sincron√≠a entre los adaptadores y el n√∫cleo puede volverse costoso si no se automatiza adecuadamente.

- Testing cruzado: Aunque facilita las pruebas unitarias del dominio, las pruebas de integraci√≥n entre adaptadores pueden volverse m√°s t√©cnicas, especialmente si hay muchas implementaciones por puerto.

**Casos ideales para aplicar arquitectura hexagonal**

- Sistemas con m√∫ltiples interfaces de entrada/salida: Como aplicaciones que ofrecen interfaz web, API REST y l√≠nea de comandos en simult√°neo.

- Proyectos que usar√°n diferentes tecnolog√≠as a lo largo del tiempo: Por ejemplo, sistemas que inicialmente usan SQLite pero luego migran a PostgreSQL o MongoDB, sin reescribir la l√≥gica del dominio.

- Aplicaciones que deben integrarse con servicios externos: Como pasarelas de pago, servicios de notificaci√≥n (SMS, email), o APIs de terceros que pueden cambiar con frecuencia.

- Entornos con alta exigencia de pruebas automatizadas: Como sistemas financieros, donde el dominio debe estar probado independientemente de la base de datos o del servidor.

### Implementaci√≥n del sistema

Se implement√≥ una aplicaci√≥n de gesti√≥n de tareas basada en el patr√≥n de arquitectura hexagonal. El c√≥digo se organiz√≥ en cuatro capas principales:

1. **Dominio (`domain/`)**  
   Contiene la entidad `Tarea`, la cual representa el n√∫cleo del modelo de negocio. Esta entidad define sus propiedades, como t√≠tulo, estado de completado y fecha de creaci√≥n. Aqu√≠ se encapsulan las reglas de negocio independientes de cualquier tecnolog√≠a externa.

2. **Puertos (`ports/`)**  
   Define las interfaces que el dominio necesita para interactuar con el exterior.  
   - `RepositorioDeTareas`: un puerto que define m√©todos como `guardar`, `listar`, etc.  
   - `ServicioDeTareas`: caso de uso que utiliza el puerto para operar sobre las tareas. Act√∫a como la capa de aplicaci√≥n que orquesta la l√≥gica.

3. **Adaptadores (`adapters/`)**  
   Proveen implementaciones concretas de los puertos.  
   - `repositorio_memoria.py`: guarda las tareas en una lista de Python (modo temporal).  
   - `repositorio_archivo.py`: guarda y carga tareas desde un archivo `.txt`.  
   - `repositorio_sqlite.py`: persiste tareas en una base de datos SQLite.  
   - `api_rest.py`: adaptador de entrada para exponer la l√≥gica mediante FastAPI (REST).  

4. **Configuraci√≥n Principal (`main.py`)**  
   Permite ejecutar el sistema en dos modos:
   - **Consola** (`s`): interact√∫a directamente con el servicio desde la l√≠nea de comandos.
   - **API REST** (`n`): expone la l√≥gica como endpoints HTTP y genera Swagger UI autom√°ticamente.

Este enfoque permite probar y extender el sistema f√°cilmente. Por ejemplo, es posible a√±adir un nuevo adaptador (como una interfaz web o un bot de Telegram) sin modificar el dominio.

---

### Link del Repositorio

https://github.com/DmitriVurb/Arquitectura_Hexagonal.git

#### Referencias

- Brown, S. (2016). *Software Architecture for Developers*. Coding the architecture. Recuperado de https://static.codingthearchitecture.com/sddconf2014-software-architecture-for-developers-extract.pdf 
- Cockburn, A. (2005). *The Hexagonal (Ports & Adapters) Architecture*. Recuperado de https://alistair.cockburn.us/hexagonal-architecture/
- Evans, E. (2003). Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison-Wesley. Recuperado de https://fabiofumarola.github.io/nosql/readingMaterial/Evans03.pdf
- Fowler, M. (2002). *Patterns of Enterprise Application Architecture*. Addison-Wesley. Recuperado de https://dl.ebooksworld.ir/motoman/Patterns%20of%20Enterprise%20Application%20Architecture.pdf
- Martin, R. C. (2018). Clean Architecture: A Craftsman's Guide to Software Structure and Design. Prentice Hall. Recuperado de https://agorism.dev/book/software-architecture/%28Robert%20C.%20Martin%20Series%29%20Robert%20C.%20Martin%20-%20Clean%20Architecture_%20A%20Craftsman%E2%80%99s%20Guide%20to%20Software%20Structure%20and%20Design-Prentice%20Hall%20%282017%29.pdf


