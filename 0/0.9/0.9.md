# 0.9. Trabajo Individual - Patrones Cloud (Informes y Videos)
- [Volver al √≠ndice](/0/0.md)

## Integrantes 01: Rodrigo De los R√≠os
Escriban su desarollo.

# Patr√≥n Gateway Routing

## √çndice
- [Introducci√≥n](#introducci√≥n)
- [¬øQu√© es el Patr√≥n Gateway Routing?](#qu√©-es-el-patr√≥n-gateway-routing)
- [Problema que Resuelve](#problema-que-resuelve)
- [Arquitectura del Patr√≥n](#arquitectura-del-patr√≥n)
- [Componentes Principales](#componentes-principales)
- [Implementaci√≥n](#implementaci√≥n)
- [Casos de Uso](#casos-de-uso)
- [Ventajas y Desventajas](#ventajas-y-desventajas)
- [Demo del C√≥digo](#demo-del-c√≥digo)
- [Mejores Pr√°cticas](#mejores-pr√°cticas)
- [Referencias](#referencias)

## Introducci√≥n

El patr√≥n **Gateway Routing** es un patr√≥n de dise√±o arquitect√≥nico que permite dirigir las solicitudes de los clientes hacia diferentes servicios backend bas√°ndose en el contenido de la solicitud. Este patr√≥n es especialmente √∫til en arquitecturas de microservicios donde m√∫ltiples servicios necesitan ser accesibles a trav√©s de un √∫nico punto de entrada.

![Diagrama conceptual mostrando m√∫ltiples clientes conect√°ndose a un gateway que dirige las solicitudes a diferentes servicios backend](./assets/diagrama_conceptual.png)

## ¬øQu√© es el Patr√≥n Gateway Routing?

El Gateway Routing act√∫a como un proxy reverso inteligente que examina las solicitudes entrantes y las dirige al servicio backend apropiado bas√°ndose en criterios predefinidos como:

- **Ruta URL**: `/api/users` ‚Üí Servicio de Usuarios
- **M√©todo HTTP**: GET, POST, PUT, DELETE
- **Headers**: Tipo de contenido, autenticaci√≥n
- **Par√°metros de consulta**: Versi√≥n de API, regi√≥n
- **Carga √∫til**: Contenido del cuerpo de la solicitud

![Diagrama de flujo mostrando el proceso de decisi√≥n del gateway routing con diferentes criterios de enrutamiento](./assets/diagrama_procesos.png)

## Problema que Resuelve

### Desaf√≠os Tradicionales:
- **M√∫ltiples puntos de entrada**: Los clientes necesitan conocer las URLs espec√≠ficas de cada servicio
- **Complejidad de configuraci√≥n**: Cada cliente debe manejar diferentes endpoints
- **Falta de flexibilidad**: Cambios en la arquitectura backend requieren modificaciones en todos los clientes
- **Gesti√≥n de pol√≠ticas**: Aplicar autenticaci√≥n, autorizaci√≥n y rate limiting en m√∫ltiples servicios

### Soluci√≥n del Gateway Routing:
- **Punto de entrada √∫nico**: Un solo endpoint para todos los servicios
- **Enrutamiento inteligente**: Decisiones autom√°ticas basadas en reglas
- **Abstracci√≥n de la complejidad**: Los clientes no necesitan conocer la arquitectura interna
- **Gesti√≥n centralizada**: Pol√≠ticas aplicadas en un solo lugar

## Arquitectura del Patr√≥n

La arquitectura del Gateway Routing se compone de varios elementos clave que trabajan en conjunto:

```
Cliente ‚Üí Gateway Router ‚Üí Servicio Backend Apropiado
```

### Flujo de Datos:
1. **Recepci√≥n**: El gateway recibe la solicitud del cliente
2. **An√°lisis**: Examina la solicitud (URL, headers, etc.)
3. **Decisi√≥n**: Aplica las reglas de enrutamiento
4. **Reenv√≠o**: Dirige la solicitud al servicio backend correcto
5. **Respuesta**: Retorna la respuesta al cliente

![Diagrama de secuencia mostrando el flujo completo de una solicitud a trav√©s del gateway](./assets/diagrama_secuencial.png)

## Componentes Principales

### 1. **Router Gateway**
- Componente central que recibe todas las solicitudes
- Contiene la l√≥gica de enrutamiento
- Mantiene el mapeo de rutas a servicios

### 2. **Reglas de Enrutamiento**
- Configuraci√≥n que define c√≥mo dirigir las solicitudes
- Puede ser est√°tica (archivos de configuraci√≥n) o din√°mica (base de datos)
- Incluye criterios de coincidencia y destinos

### 3. **Servicios Backend**
- Microservicios que procesan las solicitudes espec√≠ficas
- Pueden estar en diferentes servidores o contenedores
- Independientes entre s√≠

### 4. **Balanceador de Carga (Opcional)**
- Distribuye la carga entre m√∫ltiples instancias del mismo servicio
- Mejora la disponibilidad y rendimiento

![Diagrama de componentes mostrando la interacci√≥n entre todos los elementos del patr√≥n](./assets/diagrama_components.png)

## Implementaci√≥n

### Tecnolog√≠as Comunes:
- **API Gateways**: Kong, Zuul, Ocelot, AWS API Gateway
- **Proxies Reversos**: Nginx, HAProxy, Envoy
- **Frameworks**: Express.js con middleware personalizado, Spring Cloud Gateway

## Casos de Uso

### 1. **Arquitectura de Microservicios**
- M√∫ltiples servicios independientes
- Necesidad de un punto de entrada unificado
- Diferentes tecnolog√≠as por servicio

### 2. **Versionado de APIs**
- Diferentes versiones de la misma API
- Migraci√≥n gradual entre versiones
- Compatibilidad hacia atr√°s

### 3. **Segmentaci√≥n por Regi√≥n**
- Servicios espec√≠ficos por ubicaci√≥n geogr√°fica
- Cumplimiento de regulaciones locales
- Optimizaci√≥n de latencia

### 4. **A/B Testing**
- Dirigir porcentajes de tr√°fico a diferentes versiones
- Pruebas de nuevas funcionalidades
- An√°lisis de rendimiento

## Ventajas y Desventajas

### **Ventajas:**
- **Simplicidad para el cliente**: Un solo punto de entrada
- **Flexibilidad**: F√°cil modificaci√≥n de rutas sin afectar clientes
- **Escalabilidad**: Agregar nuevos servicios transparentemente
- **Gesti√≥n centralizada**: Pol√≠ticas y monitoreo en un lugar
- **Abstracci√≥n**: Los clientes no conocen la arquitectura interna

### **Desventajas:**
- **Punto √∫nico de falla**: Si el gateway falla, todos los servicios son inaccesibles
- **Complejidad adicional**: Necesidad de gestionar y mantener el gateway
- **Latencia**: Hop adicional en cada solicitud
- **Cuello de botella**: Posible limitaci√≥n de rendimiento
- **Dependencia**: Todos los servicios dependen del gateway

## Demo del C√≥digo
El presente repositorio p√∫blico contiene una implementaci√≥n completa del patr√≥n Gateway Routing que demuestra:
[enlace a github](https://github.com/RoudiOlding/gateway_routing_pattern.git)

## Diapositivas de exposici√≥n
Las diapositivas usadas para presentar el tema se encuentran tambi√©n a su disposici√≥n en la carpeta '0.9/assets/exposicion_03_individual'.
[Enlace del dispositivo](./assets/exposicion_03_individual.pptx)

## Mejores Pr√°cticas

### 1. **Dise√±o de Rutas**
- Usar convenciones RESTful consistentes
- Incluir versionado en las URLs (`/v1/api/users`)
- Evitar rutas demasiado espec√≠ficas

### 2. **Gesti√≥n de Errores**
- Implementar timeouts apropiados
- Manejar errores de servicios downstream
- Proporcionar mensajes de error √∫tiles

### 3. **Monitoreo y Logging**
- Registrar todas las solicitudes y respuestas
- Implementar m√©tricas de rendimiento
- Alertas para servicios no disponibles

### 4. **Seguridad**
- Validar todas las solicitudes entrantes
- Implementar rate limiting
- Usar HTTPS en producci√≥n

### 5. **Rendimiento**
- Implementar caching cuando sea apropiado
- Optimizar las reglas de enrutamiento
- Considerar conexiones keep-alive

### 6. **Alta Disponibilidad**
- Implementar m√∫ltiples instancias del gateway
- Usar health checks para servicios backend
- Implementar circuit breakers

## Referencias

### Documentaci√≥n Oficial:
- [Microsoft Azure - Gateway Routing Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-routing)
- [AWS API Gateway Documentation](https://docs.aws.amazon.com/apigateway/)
- [Kong Gateway Documentation](https://docs.konghq.com/)

### Art√≠culos y Recursos:
- [Microservices Patterns by Chris Richardson](https://microservices.io/patterns/apigateway.html)
- [Building Microservices by Sam Newman](https://samnewman.io/books/building_microservices/)
- [API Gateway Pattern - Martin Fowler](https://martinfowler.com/articles/gateway-pattern.html)

### Herramientas y Frameworks:
- [Nginx](https://nginx.org/en/docs/)
- [HAProxy](https://www.haproxy.org/)
- [Envoy Proxy](https://www.envoyproxy.io/)
- [Spring Cloud Gateway](https://spring.io/projects/spring-cloud-gateway)
- [Ocelot (.NET)](https://github.com/ThreeMammals/Ocelot)

### Repositorios de Ejemplo:
- [Netflix Zuul Examples](https://github.com/Netflix/zuul)
- [Kong Gateway Examples](https://github.com/Kong/kong)
- [Microservices Demo Projects](https://github.com/microservices-demo)

---

## Integrantes 02: Adri√°n Duarte
Escriban su desarollo.

## Integrantes 03: Alejandro Ch√°vez
# Patr√≥n Cloud Circuit Breaker
El patr√≥n Cloud Circuit Breaker es una adaptaci√≥n del patr√≥n Circuit Breaker aplicado en entornos de computaci√≥n en la nube y microservicios. Su objetivo principal es manejar fallos en servicios distribuidos, evitando que un sistema colapse debido a errores en cascada cuando un servicio remoto falla o est√° saturado, aumentando la estabilidad del sistema y su resiliencia a errores. 

## Problema
En sistemas distribuidos y aplicaciones en la nube, los servicios suelen comunicarse entre s√≠ mediante llamadas remotas. Sin embargo, estos servicios pueden fallar debido a los siguientes eventos:

- Latencia elevada: Un servicio puede responder lentamente debido a sobrecarga.
- Fallas temporales: Errores en bases de datos, timeouts o indisponibilidad de recursos.
- Cascada de errores: Si un servicio dependiente falla, puede propagar el error a otros componentes, degradando el sistema completo.

Generando problemas como:

- Mayor consumo de recursos mientras se reintentan llamadas fallidas.
- Experiencia de usuario degradada debido a tiempos de espera prolongados.
- Posibles colapsos en sistemas cr√≠ticos.

## Soluci√≥n
El patr√≥n Circuit Breaker act√∫a como un intermediario entre el cliente y el servicio, monitoreando las fallas. El comportamiento de este patr√≥n es similar a un cortacircuito el√©ctrico con tres estados:

- Cerrado: Las solicitudes fluyen normalmente al servicio.
- Abierto: Si el servicio falla repetidamente, el circuito se abre y las solicitudes se desv√≠an.
- Medio Abierto: Despu√©s de un tiempo, permite algunas solicitudes para probar si el servicio se recuper√≥.

### Complemento con otras plataformas
- Netflix Hystrix populariz√≥ este patr√≥n en microservicios.
- Resilience4j y Polly son alternativas modernas.
- En AWS, AWS Lambda puede usar Step Functions con manejo de errores similar.

### Casos de aplicaci√≥n

#### Sector Financiero
En bancos y pasarelas de pago, los servicios de autorizaci√≥n de transacciones suelen depender de sistemas externos. Si un procesador de pagos comienza a fallar debido a sobrecarga, reintentos continuos podr√≠an saturar el sistema o generar cobros duplicados. Implementar Circuit Breaker permite detectar fallos r√°pidamente y activar un fallback, como almacenar transacciones en una cola para reprocesamiento posterior. Esto evita cascadas de errores y mejora la confiabilidad, tal como hace PayPal durante eventos de alta demanda.

#### E-Commerce y Retail
Plataformas como Amazon o startups de comercio electr√≥nico dependen de servicios de recomendaci√≥n en tiempo real. Si un sistema de IA que sugiere productos empieza a responder lentamente, el Circuit Breaker puede desviar las peticiones a un cach√© de "productos populares" despu√©s de superar un umbral de timeouts. As√≠, aunque las recomendaciones sean menos personalizadas, la p√°gina carga r√°pidamente, evitando p√©rdidas de ventas. Netflix emplea un enfoque similar para garantizar que los usuarios siempre tengan contenido disponible, incluso si fallan los algoritmos de recomendaci√≥n.

#### Telecomunicaciones y Log√≠stica
Aplicaciones de delivery necesitan geolocalizaci√≥n precisa para rastrear repartidores. Si la API de mapas falla, el Circuit Breaker evita reintentos innecesarios y activa un fallback: mostrar la √∫ltima ubicaci√≥n conocida o cambiar a un mapa offline. Esto mantiene la funcionalidad b√°sica sin interrumpir el servicio. Uber aplica esta t√©cnica en su sistema de rutas para manejar fallos temporales sin afectar a conductores y pasajeros.

### Aplicaci√≥n al trabajo en grupo
El patron cloud Circuit Breaker puede ser de gran utilidad para nuestro proyecto Singletone. Como cualquier plataforma dependiente de servicios web, nuestros usuarios estan constantemente enviando solicitudes a los componentes del sistema. En caso uno de estos componentes falle al comunicarse con otros, se puede dar una inestabilidad en el servicio causada por los constantes intentos de comunicaci√≥n. El patr√≥n propuesto puede mejorar este tipo de casos, si bien no va a evitar los errores de conexi√≥n, si puede evitar que estos saturen el sistema causando bajadas en el rendimiento.

## Demo

### Caso
Un servicio de backend que proporciona datos cr√≠ticos para una aplicaci√≥n web. El servicio tiene problemas intermitentes debido a alta carga con una tasa de fallos del 50%. Se necesita evitar que los fallos del servicio afecten toda la aplicaci√≥n

#### Problemas:
- Fallos repetidos del servicio saturan el cliente
- Tiempos de respuesta excesivos cuando el servicio est√° sobrecargado
- Posibilidad de fallos en cascada en todo el sistema

#### Solucion:
Implementar el patr√≥n Circuit Breaker para detectar fallos constantes y bloquear temporalmente las solicitudes entrantes para evitar caidas completas en el sistema debido a la sobresaturaci√≥n.

### Demo:
https://github.com/AleGCC/arqui-demo-CircuitBreaker

### Video:
https://youtu.be/emFXqc6Vdxw


## Integrantes 04: Angel Alcal√°
Escriban su desarollo.

# Patr√≥n Cach√© Aside

## Problema

Cuando una aplicaci√≥n necesita datos, esta resulta costoso en t√©rminos de tiempo y recursos ya que las consultas requeridas de lectura son b√°sicamente
las mismos datos, pero esto lo hace de forma repetida. En conjunto, esto ocasiona una alta latencia en las respuestas y sobrecarga el servidor de base de datos, y si estamos hablando de un sistema de alta demanda, existir√° una escalabilidad limitada.

## Soluci√≥n

El patr√≥n Cache-Aside es una estrategia para gestionar almacenamiento de cach√©
para mejorar el rendimiento del sistema.
Cuando una aplicaci√≥n necesita data, primero necesita revisar el cach√©. Si los datos son encontrados (acierto de cach√© o cache hit), es usado directamente. 
Si los datos no son encontrados (falla de cach√©), la aplicaci√≥n lo recupera
desde la principal base de datos, almacena una copia en el cach√© para uso futuro y postreriormente, usa los datos obtenidos.

Este patr√≥n reduce la carga de la base de datos, aumenta la velocidad del acceso de datos, y es ampliamente usado para mejorar la eficiencia y escalabilidad de aplicaciones asegur√°ndose frecuentemente que los datos accedidos est√©n r√°pidamente disponibles.

Este patron tambi√©n es conocido en ingl√©s como **Lazy Loading** o carga diferida

## ¬øC√≥mo logra mejorar la perfomance?

- **Acceso r√°pido a datos:** Accediendo a los datos de la memoria (cach√©) es significativamente r√°pido que recuper√°ndola desde un almacenamiento basado en discos (base de datos)
- **Reduce la carga de la base de datos:** Al desviar una porci√≥n significativa de las solicitudes de lectura hacia el cach√©, el patron disminuye el n√∫nero de consultas directas hacia la base de datos.
- **Escalabilidad:** Como la demanda del sistema se incrementa, el cach√© puede 
manejar un largo volumen de solicitudes de lectura sin poner tensi√≥n adicional a la base de datos.
- **Rendimiento mejorado:** Al descargar las tareas de recuperaci√≥n hacia el cach√©, la base de datos es libre para manejar otras operaciones.
- **Disminuye latencia:** El patron disminuye la latencia asociada con la recuperaci√≥n de datos al servir datos en cach√©.

## Casos de aplicaci√≥n

### Netflix

Una de las grandes empresas de streaming a nivel mundial, necesita una gesti√≥n eficiente para su amplio cat√°logo de pel√≠culas y shows
de TV, asegurando un acceso r√°pido a la metadata y recomendar contenidos. Por ello, usan **EVCache**, una implementaci√≥n personalizada construida sobre MEmcached, para almacenar en cach√© datos a los que se acceden con frecuencia.

### Amazon

Amazon aprovecha el patr√≥n Cache-Aside para optimizar la recuperaci√≥n de datos del producto y de la gesti√≥n de los datos del inventorio a trav√©s de su plataforma e-commerce. Para ello, usan una combinaci√≥n de una soluci√≥n de cach√© en memoria como Redis y DynamoDB Accelerator (DAX) para detalles del producto en cach√© y los datos de inventarios.

### Facebook

Facebook usa este patr√≥n para gestionar los datos de la sesi√≥n del usuario y datos de gr√°ficos de frecuencia de acceso social como perfiles de usuario y lista de amigos. Para este caso usan una combinaci√≥n de Memached y TAO (almacenamiento de datos distribuidos geogr√°ficamente) para los datos de sesioens en cach√© e informaci√≥n gr√°fica social.

## Demo

### Caso

Una aplicaci√≥n de comercio electr√≥nico necesita mostrar el precio de un producto en su p√°gina web. Este dato est√° en una base de datos SQL, pero leerlo frecuentemente desde all√≠ genera una carga alta y tiempos de respuesta lentos.

### Problemas dados

- Las consultas frecuentes a la base de datos causan latencia y sobrecarga
- Muchos productos no cambian de precio con frecuencia, por lo que se hace lecturas innecesarias a la base de datos.

### Soluci√≥n 

Usar el patron Cache-Aside para agilizar las consultas y como resultado, el rendimiento del sistema.

#### Pasos Previos

##### Docker Desktop

Primero se debe instalar Docker Desktop en este enlace: https://www.docker.com/products/docker-desktop/

##### Visual Studio Code

Para ejecutar el c√≥digo en cuesti√≥n, previamente es necesario instalar VSCode
para poder correr, por ello se debe descargar en este enlace: https://code.visualstudio.com/download

#### Despliegue de Redis en Docker

Una vez en Docker Desktop, se debe ir a la barra de b√∫squeda y buscar redis, luego presionar run y configurar de la siguiente forma:

```
Container name: redis-demo
Puertos: 6379
```

Con ello, el contenedor de redis estar√° listo.

#### Configuraciones en VSCode

Una vez instalado VSCode, se debe configurar un entorno virtual como medida de
precauci√≥n. Por ello es necesario abrir la terminal y correr el siguiente comando:

```terminal
python -m venv demo       
```
Con ello, se crea el entorno virtual llamado **demo**

Ahora, debemos crear la carpeta del entorno virtual ingresando el siguiente comando a la terminal:

```terminal
demo\Scripts\activate    
```

Finalmente, nos aparecer√° un par√©ntesis con letras verdes, lo cual nos indica que estamos dentro de nuestro entorno virtual. En este paso es necesario instalar redis en nuestro entorno virtual para que el c√≥digo funcione.

```terminal
pip install redis   
```
#### C√≥digo

Para probar el patr√≥n Cache-Aside, vamos a usar un c√≥digo en python que buscar√° optimizar la base de datos y las consultas. Para ello, usar√° las consultas usando Redis, el cual est√° corriendo en Docker. Lo que har√° el c√≥digo es obtener el precio de un producto desde Redis, y si no est√°, lo busca en una base de datos simulada y luego lo guarda en Redis para futuras consultas.

```python
import redis
import time

# Simulaci√≥n de base de datos
fake_db = {
    "product:1": {"price": 99.99},
    "product:2": {"price": 149.99},
}

# Conexi√≥n a Redis
cache = redis.Redis(host='localhost', port=6379, decode_responses=True)

def get_product_price(product_id):
    key = f"product:{product_id}:price"

    # 1. Intentar obtener de la cach√©
    cached_price = cache.get(key)
    if cached_price:
        print(f"‚úÖ Cache hit para {product_id}: S/{cached_price}")
        return float(cached_price)

    # 2. Si no est√° en la cach√©, buscar en "base de datos"
    print(f"‚ùå Cache miss para {product_id}")
    product_data = fake_db.get(f"product:{product_id}")
    
    if product_data:
        price = product_data["price"]

        # 3. Guardar en cach√© (expira en 10 segundos)
        cache.setex(key, 10, price)
        print(f"üì• Guardado en cach√©: {key} -> S/{price}")
        return price

    print(f"‚ö†Ô∏è Producto {product_id} no encontrado.")
    return None

# DEMO de uso
for _ in range(3):
    print("Precio del producto 1:", get_product_price(1))
    time.sleep(3)

```

**Enlace a la demo:** https://www.youtube.com/watch?v=plIYDE_K8K0

## Referencias

https://www.geeksforgeeks.org/system-design/cache-aside-pattern


## Integrantes 05: Erick Valderrama
Escriban su desarollo.