# 8.4. Patrones Cloud

## **Decisión 1: Patrón Gateway Routing**

**Título:**  
Implementación de enrutamiento inteligente mediante API Gateway

**Contexto:**  
Singletone opera con múltiples microservicios especializados (gestión de usuarios, biblioteca musical, exploración musical, visualización de perfil, gestión de planes) que requieren un punto de entrada unificado para el frontend y servicios externos. Se necesita un mecanismo de enrutamiento que dirija las peticiones al microservicio apropiado basándose en la URL, headers, y contexto de la solicitud.

**Alternativas:**
1. **Enrutamiento en el Frontend:**
   - El cliente decide directamente a qué microservicio llamar
   - Simplicidad inicial de implementación
   - Expone la arquitectura interna al cliente
   - Dificulta cambios en la estructura de servicios

2. **Gateway Routing Centralizado:**
   - API Gateway enruta peticiones basándose en reglas configurables
   - Abstrae la arquitectura interna de los clientes
   - Facilita cambios y versionado de servicios
   - Punto central para políticas de enrutamiento

3. **Service Discovery Dinámico:**
   - Servicios se registran automáticamente y el gateway los descubre
   - Máxima flexibilidad para servicios dinámicos
   - Complejidad alta de implementación
   - Sobrecarga para arquitectura actual

**Criterios de elección:**
- **Abstracción:** Ocultar complejidad de microservicios al cliente
- **Flexibilidad:** Facilidad para redirigir tráfico y hacer cambios
- **Mantenibilidad:** Centralización de reglas de enrutamiento
- **Performance:** Latencia mínima en el proceso de enrutamiento

**Decisión:**
Gateway Routing Centralizado.

**Reglas de enrutamiento implementadas:**
- `/api/users/*` → Microservicio Gestión de Usuarios
- `/api/library/*` → Microservicio Gestión de Biblioteca  
- `/api/exploration/*` → Microservicio Exploración Musical
- `/api/profile/*` → Microservicio Visualización de Perfil
- `/api/plans/*` → Microservicio Gestión de Planes

**Funcionalidades adicionales:**
- **Versionado de APIs:** Soporte para `/api/v1/` y `/api/v2/`
- **Enrutamiento por headers:** Redirigir según tipo de cliente
- **Balanceamento de carga:** Distribución entre instancias de microservicios

**Sustento:**  
El patrón Gateway Routing es esencial para Singletone porque centraliza y simplifica la gestión del enrutamiento hacia los microservicios especializados de la plataforma musical. Al implementar reglas de enrutamiento inteligentes en el API Gateway, se abstrae completamente la arquitectura interna de microservicios del frontend, permitiendo cambios en la estructura de servicios sin afectar el cliente. Este patrón facilita la implementación de funcionalidades avanzadas como versionado de APIs, enrutamiento condicional basado en headers, y balanceamento de carga automático entre instancias de servicios, mejorando tanto la flexibilidad operacional como la experiencia del desarrollador frontend.

---

## **Decisión 2: Patrón Cache Aside**

**Título:**  
Implementación de caché lateral para optimización de rendimiento

**Contexto:**  
Singletone maneja consultas frecuentes a datos que cambian con poca frecuencia: metadatos de canciones, información de artistas, configuraciones de usuario, y resultados de recomendaciones musicales. Las consultas repetitivas a las bases de datos principales generan latencia innecesaria y carga computacional. Se requiere una estrategia de caché que mejore el rendimiento sin comprometer la consistencia de datos.

**Alternativas:**
1. **Sin Caché:**
   - Todas las consultas van directamente a la base de datos
   - Simplicidad de implementación
   - Alta latencia para consultas frecuentes
   - Sobrecarga innecesaria en bases de datos principales

2. **Cache Aside (Lazy Loading):**
   - Aplicación gestiona el caché manualmente
   - Datos se cargan en caché solo cuando se solicitan
   - Control total sobre qué y cuándo cachear
   - Complejidad adicional en lógica de aplicación

3. **Write-Through Cache:**
   - Datos se escriben simultáneamente en caché y base de datos
   - Consistencia garantizada entre caché y almacén principal
   - Latencia adicional en operaciones de escritura
   - Complejidad en sincronización

**Criterios de elección:**
- **Performance:** Reducción significativa de latencia en consultas frecuentes
- **Control:** Flexibilidad para decidir qué datos cachear
- **Consistencia:** Balance entre rendimiento y actualización de datos
- **Implementación actual:** Aprovechamiento de infraestructura Redis existente

**Decisión:**
Cache Aside (Lazy Loading).

**Datos cacheados implementados:**
- **Sesiones de usuario:** Tokens de autenticación y preferencias (TTL: 1 hora)
- **Contadores de límites:** Valoraciones semanales por usuario (TTL: 24 horas)
- **Metadatos de canciones:** Información de artistas y álbumes (TTL: 7 días)
- **Resultados de recomendaciones:** Listas personalizadas generadas por IA (TTL: 12 horas)

**Estrategia de invalidación:**
- **TTL automático:** Expiración basada en tiempo según tipo de dato
- **Invalidación manual:** Eliminación explícita cuando se actualizan datos críticos
- **Patrón de fallback:** Si caché falla, consultar base de datos y repoblar caché

**Sustento:**  
El patrón Cache Aside es la elección más acertada para Singletone porque la plataforma ya tiene implementada la infraestructura Redis necesaria y maneja patrones de acceso ideales para este tipo de caché. Los datos musicales como metadatos de canciones, información de artistas y resultados de recomendaciones se consultan frecuentemente pero cambian con poca frecuencia, haciendo que el lazy loading sea altamente eficiente. Además, este patrón proporciona el control granular necesario para manejar diferentes TTLs según la naturaleza de cada tipo de dato musical, desde sesiones de usuario que requieren actualización frecuente hasta metadatos de canciones que pueden permanecer válidos por días, optimizando significativamente el rendimiento de la plataforma sin comprometer la consistencia de datos críticos.