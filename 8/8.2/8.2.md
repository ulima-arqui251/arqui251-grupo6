# 8.2. Patrones de Componente y Conector

## **Decisión 1: Patrón de Componente y Conector - Broker**

**Título:**  
Implementación de patrón Broker mediante API Gateway centralizado

**Contexto:**  
Singletone opera con múltiples microservicios especializados (gestión de usuarios, biblioteca musical, recomendaciones, suscripciones) que deben comunicarse entre sí y con el frontend, además de integrarse con servicios externos como Auth0, Stripe y Hugging Face API. Se requiere un mecanismo de comunicación que desacople los componentes y gestione el enrutamiento de manera centralizada.

**Alternativas:**
1. **Comunicación Directa:**
   - Cada servicio se comunica directamente con otros servicios
   - Menor latencia en comunicación punto a punto
   - Genera alto acoplamiento entre servicios
   - Dificulta mantenimiento y evolución independiente

2. **Patrón Broker con API Gateway:**
   - Intermediario centralizado que maneja todas las comunicaciones
   - Desacopla completamente los servicios entre sí
   - Facilita implementación de cross-cutting concerns (autenticación, logging)
   - Punto único de entrada para el frontend

3. **Service Mesh:**
   - Red de comunicación dedicada entre microservicios
   - Mayor control sobre tráfico inter-servicios
   - Complejidad de implementación alta
   - Sobrecarga para el tamaño actual del sistema

**Criterios de elección:**
- **Desacoplamiento:** Independencia entre servicios y componentes
- **Centralización de responsabilidades:** Gestión unificada de autenticación, enrutamiento y políticas
- **Simplicidad de integración:** Facilidad para agregar nuevos servicios o clientes
- **Coherencia con arquitectura actual:** Aprovechamiento de componentes ya implementados

**Decisión:**
Patrón Broker con API Gateway centralizado.

- **Enrutamiento inteligente:** Dirigir peticiones al microservicio apropiado según la funcionalidad
- **Gestión de autenticación:** Validación centralizada con Auth0 antes de reenviar peticiones
- **Balanceamento de carga:** Distribución eficiente entre instancias de microservicios
- **Punto único de entrada:** Interface consolidada para frontend y servicios externos

**Sustento:**  
El patrón Broker mediante API Gateway es la elección más acertada para Singletone porque la plataforma ya cuenta con esta implementación funcionando eficazmente como punto central de comunicación. Este patrón proporciona el desacoplamiento necesario entre los microservicios especializados, permitiendo que cada uno evolucione independientemente sin afectar a otros componentes. Además, centraliza responsabilidades críticas como la autenticación con Auth0, el enrutamiento inteligente y la gestión de políticas de acceso, simplificando la arquitectura general y facilitando la integración de nuevos servicios o la incorporación de clientes adicionales (como futuras aplicaciones móviles).

---

## **Decisión 2: Patrón de Componente y Conector - Datos Compartidos**

**Título:**  
Arquitectura de datos compartidos con múltiples bases de datos especializadas

**Contexto:**  
Singletone maneja diferentes tipos de datos con requisitos de almacenamiento y acceso diversos: datos relacionales de usuarios y suscripciones, catálogo musical documental, y datos de sesión/caché de alto rendimiento. Los múltiples microserviicos requieren acceso a repositorios centrales de datos según su dominio específico.

**Alternativas:**
1. **Base de Datos Única:**
   - Todos los datos en una sola base de datos relacional
   - Simplicidad de gestión y respaldos
   - Limitaciones de rendimiento para diferentes tipos de consultas
   - Dificultad para optimizar según patrones de acceso específicos

2. **Bases de Datos por Microservicio:**
   - Cada servicio con su propia base de datos independiente
   - Máximo desacoplamiento entre servicios
   - Complejidad en consultas que requieren datos de múltiples dominios
   - Dificultad para mantener consistencia transaccional

3. **Datos Compartidos con Múltiples Bases Especializadas:**
   - Diferentes tipos de bases de datos según la naturaleza de los datos
   - Optimización específica para patrones de acceso de cada dominio
   - Repositorios centrales accesibles por múltiples microservicios
   - Balance entre performance y simplicidad

**Criterios de elección:**
- **Optimización por tipo de dato:** Uso de tecnologías de almacenamiento más adecuadas para cada dominio
- **Performance:** Velocidad de acceso según patrones de consulta específicos
- **Consistencia:** Mantenimiento de integridad de datos críticos
- **Escalabilidad:** Capacidad de escalar almacenamiento según demanda por dominio

**Decisión:**
Datos Compartidos con Múltiples Bases Especializadas.

- **Base de Datos Relacional (PostgreSQL):** Usuarios, planes de suscripción, metadatos estructurados
- **Base de Datos Documental (MongoDB):** Catálogo musical, artistas, álbumes con estructura flexible
- **Base de Datos Clave-Valor (Redis):** Caché de sesiones, contadores de límites, datos temporales

**Sustento:**  
La arquitectura de datos compartidos con múltiples bases especializadas es la más adecuada para Singletone porque permite optimizar el almacenamiento según la naturaleza específica de cada tipo de datos musicales. La base relacional proporciona consistencia ACID para datos críticos como usuarios y suscripciones, mientras que la base documental ofrece flexibilidad para el catálogo musical con metadatos variables, y la base clave-valor garantiza acceso ultra-rápido para sesiones y caché. Esta estrategia, ya implementada en la arquitectura actual, ha demostrado ser efectiva para balancear performance, consistencia y escalabilidad, permitiendo que cada microservicio acceda a los repositorios más apropiados para sus necesidades específicas.

---

## **Decisión 3: Patrón de Componente y Conector - Publicar-Suscribir (Opcional)**

**Título:**
Sistema de eventos asíncronos para notificaciones y actualizaciones en tiempo real

**Contexto:**
Singletone requiere actualizaciones en tiempo real entre componentes cuando ocurren eventos significativos: nuevas valoraciones que afectan recomendaciones, cambios en biblioteca que impactan visualizaciones de perfil, y notificaciones de límites de suscripción. Se necesita un mecanismo de comunicación asíncrona que desacople la generación de eventos de su procesamiento.

**Alternativas:**
1. **Comunicación Síncrona Directa:**
   - Llamadas API directas entre microservicios cuando ocurren cambios
   - Simplicidad de implementación inicial
   - Alto acoplamiento entre servicios
   - Problemas de rendimiento si un servicio está lento

2. **Patrón Publicar-Suscribir:**
   - Eventos asíncronos a través de message broker
   - Desacoplamiento temporal entre productores y consumidores
   - Facilita agregar nuevos suscriptores sin modificar publicadores
   - Complejidad adicional de infraestructura

3. **Polling Periódico:**
   - Servicios consultan cambios periódicamente
   - Simplicidad de implementación
   - Latencia alta para actualizaciones
   - Carga innecesaria en bases de datos

**Criterios de elección:**
- **Tiempo real:** Velocidad de propagación de cambios críticos
- **Desacoplamiento:** Independencia entre generadores y consumidores de eventos
- **Escalabilidad:** Capacidad de agregar nuevos suscriptores sin impacto
- **Implementación gradual:** Posibilidad de introducir el patrón progresivamente

**Decisión:**
Patrón Publicar-Suscribir (implementación gradual).

**Eventos principales a implementar:**
- **Valoración de canción:** Actualizar recomendaciones y estadísticas de perfil
- **Cambio en biblioteca:** Sincronizar visualizaciones y métricas
- **Límite de suscripción alcanzado:** Notificar restricciones en tiempo real
- **Nueva recomendación generada:** Actualizar interfaces de usuario

**Sustento:**  
El patrón Publicar-Suscribir es recomendable para Singletone como mejora evolutiva porque permitirá desacoplar temporalmente los microservicios y habilitar actualizaciones en tiempo real que enriquecerán la experiencia del usuario. Aunque no está implementado actualmente, su introducción gradual facilitará la propagación eficiente de eventos críticos como nuevas valoraciones que deben actualizar recomendaciones, o cambios en la biblioteca que impactan las visualizaciones del perfil. Este patrón preparará la plataforma para futuras funcionalidades que requieran mayor interactividad y sincronización entre componentes, manteniendo la filosofía de desacoplamiento ya establecida en la arquitectura.
