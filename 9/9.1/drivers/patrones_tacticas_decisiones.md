# FLUJO PRINCIPAL
Búsqueda → Visualizar Álbum → Valorar Álbum → Mostrar en Perfil

# DECISIONES
Arquitectura de microservicios (Asignación de Responsabilidades), Enfoque híbrido (Asignación de Responsabilidades), Delegar a IdP (Asignación de Responsabilidades), Comunicación síncrona (RESTful API) (Modelo de Coordinación), Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orienda a documentos y clave-valor (Modelo de Datos), Instancia de BD por microservicio (Modelado de datos), Mapeo uno a uno (Mapeo entre elementos de Arquitectura), React (Elección de Tecnología), Node.js con Express.js (Elección de Tecnología), PostgreSQL (Elección de Tecnología), MongoDB (Elección de Tecnología), Redis (Elección de Tecnología), Kubernetes (Elección de Tecnología), Separar los controladores en tres componentes específicos (Asignación de Responsabilidades), Coordinación basada en orquestación mediante un servicio centralizado (UserService) (Modelo de Coordinación), Modelo relacional normalizado (SQL - PostgresSQL) (Modelo de Datos), Mapeo directo entre componentes (controlador → servicio → repositorio) (Mapeo entre elementos de Arquitectura), Auth0 (IdP) (Elección de Tecnología), Separar en componentes independientes por tipo de información (Asignación de Responsabilidades), Modelo basado en servicios coordinados mediante un controlador central de perfil (Modelo de Coordinación), Modelo separado por dominios (composición de modelos especializados) (Modelo de Datos), El backend construye el modelo completo del perfil y lo entrega listo al frontend (Mapeo entre elementos de Arquitectura), Creación de componentes propios (Elección de Tecnología), Módulo de Búsqueda con Acción Delegada (Asignación de Responsabilidades), Comunicación vía REST API (Modelo de Coordinación), Comunicación síncrona vía HTTP (REST) (Modelo de Coordinación), Documentos embebidos por jerarquía de uso (Modelo de Datos), Mapeo parcial con índices denormalizados (Mapeo entre elementos de Arquitectura), Paginación basada en cursores con MongoDB y autocompletado por prefijo con Redis como caché (Elección de Tecnología), Utilizar una tabla de "relación" explícita con un campo de estado (Asignación de Responsabilidades), Responsabilidad centralizada en el microservicio de Biblioteca (Asignación de Responsabilidades), El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente (Modelo de Coordinación), El backend notifica al frontend mediante un canal en tiempo real cuando todas las canciones han sido valoradas (Modelo de Coordinación), Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado (Modelo de Datos), Crear una colección separada de "Valoraciones" en MongoDB (Modelo de Datos), Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones" (Modelo de Datos), Mapeo directo: Cada entidad Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario (Mapeo entre elementos de Arquitectura), Utilizar un campo de texto (string) llamado `estado` (Mapeo entre elementos de Arquitectura), PostgreSQL (sequelize), MongoDB (mongoose) (Elección de Tecnología), WebSockets (Elección de Tecnología), Uso de LLM con procesamiento directo (Asignación de Responsabilidades), Integración con API de LLM externa (Asignación de Responsabilidades), Nueva consulta directa al LLM (Asignación de Responsabilidades), Recepción de eventos REST de valoraciones para actualización dinámica (Modelo de Coordinación), El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario (Modelo de Coordinación), Actualización en segundo plano con REST API y polling (Modelo de Coordinación), Entidad persistente de recomendaciones (Modelo de Datos), Mapeo directo con colección exclusiva para recomendaciones (Mapeo entre elementos de Arquitectura), API basada en LLM (Elección de Tecnología), Hugging Face Inference API (Elección de Tecnología), Separación en componentes especializados (Asignación de Responsabilidades), Responsabilidad del microservicio de Gestión de Planes (Asignación de Responsabilidades), Coordinación secuencial síncrona (Modelo de Coordinación), Coordinación centralizada mediante servicio orquestador (Modelo de Coordinación), Modelo híbrido PostgreSQL + Redis (Modelo de Datos), Almacenamiento en Redis con expiración automática (Modelo de Datos), Mapeo optimizado por uso con sincronización automática (Mapeo entre elementos de Arquitectura), Mapeo mediante sistema de permisos granular (Mapeo entre elementos de Arquitectura), Stripe (Elección de Tecnología), WebSockets (Elección de Tecnología)

# PATRONES
Redundancia Activa (Hot Spare) (Disponibilidad), Auto Scaling con Kubernetes (Disponibilidad), División en submódulos (Node.js) (Mantenibilidad), Wrapper JWT (TypeScript) (Mantenibilidad), Orquestación Centralizada con Controlador de Usuario (Interoperabilidad), Pool de conexiones optimizado en Sequelize (Rendimiento), Caching con Redis y TTL de 1 hora (Rendimiento), CAPTCHA progresivo + Redis Rate Limiting (Seguridad), Auth0 Passwordless / Reset integrado (Seguridad), Formulario por pasos con validación en tiempo real (Usabilidad), Asistente paso a paso con validación (Usabilidad), Pruebas automatizadas (Capacidad de ser probado), Pruebas con matriz de casos (Capacidad de ser probado), Redis Cluster con replicación (Disponibilidad), Fallback con datos recientes (Disponibilidad), Atomic Design (Mantenibilidad), Capa BFF (Backend For Frontend) (Mantenibilidad), API Gateway REST (Interoperabilidad), Capa de abstracción con cache local (Interoperabilidad), REST API Tradicional Optimizada (Rendimiento), Virtualización con lazy loading (Rendimiento), RBAC con decoradores TypeScript (Seguridad), Sanitización automatizada (Seguridad)

# PATRONES CLOUD
Descomposición Específica por Dominio (Patrón de Módulo), Patrón Broker con API Gateway centralizado (Patrón de Componente y Conector), Patrón Modelo-Vista-Controlador (MVC) (Patrón de Componente y Conector), Patrón Publicar-Suscribir (Patrón de Componente y Conector), Multi-Tier (4 niveles especializados) (Patrón de Asignación), Gateway Routing Centralizado (Patrón Cloud), Cache Aside (Lazy Loading) (Patrón Cloud), Circuit Breaker (Patrón Cloud), Patrón Bulkhead (Patrón Cloud), Rate Limiting Adaptativo (Patrón Cloud)